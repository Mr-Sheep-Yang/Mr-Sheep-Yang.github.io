
<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>数据结构</title>
</head>
<body><h1 id='第一章绪论'>第一章绪论 </h1>
<p>&nbsp;</p>
<h2 id='11数据结构的基本概念和术语'>1.1数据结构的基本概念和术语</h2>
<h3 id='111数据'>1.1.1数据</h3>
<p>是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。</p>
<h3 id='112数据元素'>1.1.2数据元素</h3>
<p>是数据的基本单位，在计算机中通常作为一个整体去考虑和处理。在有些情况下，数据元素也叫做元素，记录等。数据元素用于完整地描述一个对象</p>
<h3 id='113数据项'>1.1.3数据项</h3>
<p>是组成数据元素的，有独立含义的，不可分割的最小单位。</p>
<h3 id='114数据对象'>1.1.4数据对象</h3>
<p>性质相同的数据元素的集合，是数据的一个子集。</p>
<h2 id='12数据结构'>1.2数据结构</h2>
<p>数据结构是相互之间存在的一种或者多种特定关系的数据元素的集合。换句话说，数据结构就是带“结构”的数据元素的集合，“结构”就是数据元素之间存在的关系。数据结构包括逻辑结构和存储结构两个层次。</p>
<h3 id='121逻辑结构'>1.2.1逻辑结构</h3>
<p>数据的逻辑结构是从逻辑关系上描述数据，他与数据的存储无关，是独立于计算机的。因此数据的逻辑结构可以看作是从具问题抽象出来的数学模型</p>
<h4 id='1集合结构'>1.集合结构</h4>
<p>数据元素之间除了“属于同一集合”的关系外，无其他关系。</p>
<h4 id='2线性结构'>2.线性结构</h4>
<p>数据元素之间存在一对一的关系</p>
<h4 id='3树结构'>3.树结构</h4>
<p>数据元素之间存在一对多的关系</p>
<h4 id='4图结构或者网状结构'>4.图结构或者网状结构</h4>
<p>数据元素存在多对多的关系</p>
<h3 id='122存储结构'>1.2.2存储结构</h3>
<p>数据对象在计算机中的存储表示称为数据的数据结构，也称为物理结构。把数据对象存储到计算机时，通常要求既要存储个数据元素的数据，又要存储数据元素之间的逻辑关系。</p>
<h4 id='1顺序存储结构'>1.顺序存储结构</h4>
<p>顺序存储结构是借助元素在存储器中的相对位置来表示数据元素之间的逻辑位置，通常借助程序设计语言的数组类型来描述。</p>
<h4 id='2链式存储结构'>2.链式存储结构</h4>
<p>顺序存储结构要求所有的元素依次存放在一片连续的存储空间中，而链式存储结构，无需占用一整块存储空间。但是为了表示节点之间的关系，需要给每个节点上附加指针字段，用于存放后继元素的存储地址。所以链式存储结构通常借助于程序结构设计语言的指针类型来描述。</p>
<h2 id='13数据类型和抽象数据类型'>1.3数据类型和抽象数据类型</h2>
<h3 id='131数据类型'>1.3.1数据类型</h3>
<p>数据类型是一个值的集合和定义在这个集合上的一系列操作的总称
比如：C语言里面的整型变量，他就是某区间内的整数以及定义在这些整数上的加减乘除取模等运算的总称</p>
<h3 id='132抽象数据类型'>1.3.2抽象数据类型</h3>
<p>举例说明，计算机使用二进制表示数据，汇编语言就抽象了二进制，给出各种数据的十进制表示方式，而在高级语言里，用户可以抽象基本数据类型得到抽象的数据类型，如线性表，树，图等</p>
<p>&amp;表示的是引用，除了提供参数以外，还可以返回操作结果。</p>
<h2 id='14算法和算法评价'>1.4算法和算法评价</h2>
<p>算法(Algorithm)是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。此外，一个算法还具有下列5个重要特性:</p>
<ul>
<li>有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</li>
<li>确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</li>
<li>可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</li>
<li>输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li>
<li>输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量，</li>

</ul>
<p>通常，设计一个“好”的算法应考虑达到以下目标:</p>
<ul>
<li>正确性。算法应能够正确地解决求解问题,</li>
<li>可读性。算法应具有良好的可读性，以帮助人们理解。</li>
<li>健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li>
<li>效率与低存储量需求。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。</li>

</ul>
<h3 id='141时间复杂度'>1.4.1时间复杂度</h3>
<p>“常对幂指阶”</p>
<div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n63" cid="n63" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="72.364ex" height="2.565ex" role="img" focusable="false" viewBox="0 -883.9 31985.1 1133.9" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path><path id="MJX-1-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path><path id="MJX-1-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-1-TEX-I-1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(1152,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(1652,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(2318.8,0)"><use data-c="3C" xlink:href="#MJX-1-TEX-N-3C"></use></g><g data-mml-node="mi" transform="translate(3374.6,0)"><use data-c="1D442" xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(4137.6,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(4526.6,0)"><use data-c="1D459" xlink:href="#MJX-1-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(4824.6,0)"><use data-c="1D45C" xlink:href="#MJX-1-TEX-I-1D45C"></use></g><g data-mml-node="msub" transform="translate(5309.6,0)"><g data-mml-node="mi"><use data-c="1D454" xlink:href="#MJX-1-TEX-I-1D454"></use></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g><g data-mml-node="mi" transform="translate(6223.1,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(6823.1,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(7489.9,0)"><use data-c="3C" xlink:href="#MJX-1-TEX-N-3C"></use></g><g data-mml-node="mi" transform="translate(8545.7,0)"><use data-c="1D442" xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(9308.7,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(9697.7,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(10297.7,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(10964.4,0)"><use data-c="3C" xlink:href="#MJX-1-TEX-N-3C"></use></g><g data-mml-node="mi" transform="translate(12020.2,0)"><use data-c="1D442" xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(12783.2,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(13172.2,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(13772.2,0)"><use data-c="1D459" xlink:href="#MJX-1-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(14070.2,0)"><use data-c="1D45C" xlink:href="#MJX-1-TEX-I-1D45C"></use></g><g data-mml-node="msub" transform="translate(14555.2,0)"><g data-mml-node="mi"><use data-c="1D454" xlink:href="#MJX-1-TEX-I-1D454"></use></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g><g data-mml-node="mi" transform="translate(15468.8,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(16068.8,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(16735.6,0)"><use data-c="3C" xlink:href="#MJX-1-TEX-N-3C"></use></g><g data-mml-node="mi" transform="translate(17791.3,0)"><use data-c="1D442" xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(18554.3,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(18943.3,0)"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mn" transform="translate(633,413) scale(0.707)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g><g data-mml-node="mo" transform="translate(19979.9,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(20646.7,0)"><use data-c="3C" xlink:href="#MJX-1-TEX-N-3C"></use></g><g data-mml-node="mi" transform="translate(21702.4,0)"><use data-c="1D442" xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(22465.4,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(22854.4,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(533,413) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g></g><g data-mml-node="mo" transform="translate(23861.7,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(24528.5,0)"><use data-c="3C" xlink:href="#MJX-1-TEX-N-3C"></use></g><g data-mml-node="mi" transform="translate(25584.3,0)"><use data-c="1D442" xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(26347.3,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(26736.3,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(27336.3,0)"><use data-c="21" xlink:href="#MJX-1-TEX-N-21"></use></g><g data-mml-node="mo" transform="translate(27614.3,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(28281,0)"><use data-c="3C" xlink:href="#MJX-1-TEX-N-3C"></use></g><g data-mml-node="mi" transform="translate(29336.8,0)"><use data-c="1D442" xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(30099.8,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(30488.8,0)"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(633,413) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g></g><g data-mml-node="mo" transform="translate(31596.1,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container></div></div>
<h3 id='132空间复杂度'>1.3.2空间复杂度</h3>
<p>定义变量和函数调用会带来内存开销</p>
<p>空间复杂度是函数调用的深度</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!--内存的动态分配：分配空间   指针量=new 数据类型
                  释放空间  delete 指针变量
    内存的动态分派  分配空间   (指针类型)malloc(sizeof(数据类型)*数据个数) -->
<hr />
<h1 id='第二章线性表'>第二章线性表</h1>
<p>&nbsp;</p>
<h2 id='21线性表的定义和特点'>2.1线性表的定义和特点</h2>
<p>&nbsp;</p>
<h3 id='211线性表的定义'>2.1.1线性表的定义</h3>
<p>线性表示具有相同数据类型的n(n&gt;=0)个数据元素的有限序列，其中n为表长，当n=0时，线性表示一个空表。若用L命名线性表一般表示为</p>
<div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n80" cid="n80" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="27.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 12306.9 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-2-TEX-I-1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path><path id="MJX-2-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path><path id="MJX-2-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-2-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path><path id="MJX-2-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-2-TEX-N-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path><path id="MJX-2-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-2-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-2-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D43F" xlink:href="#MJX-2-TEX-I-1D43F"></use></g><g data-mml-node="mo" transform="translate(958.8,0)"><use data-c="3D" xlink:href="#MJX-2-TEX-N-3D"></use></g><g data-mml-node="mo" transform="translate(2014.6,0)"><use data-c="28" xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(2403.6,0)"><g data-mml-node="mi"><use data-c="1D44E" xlink:href="#MJX-2-TEX-I-1D44E"></use></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><use data-c="31" xlink:href="#MJX-2-TEX-N-31"></use></g></g><g data-mml-node="mo" transform="translate(3369.1,0)"><use data-c="2C" xlink:href="#MJX-2-TEX-N-2C"></use></g><g data-mml-node="msub" transform="translate(3813.8,0)"><g data-mml-node="mi"><use data-c="1D44E" xlink:href="#MJX-2-TEX-I-1D44E"></use></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><use data-c="32" xlink:href="#MJX-2-TEX-N-32"></use></g></g><g data-mml-node="mo" transform="translate(4779.3,0)"><use data-c="2C" xlink:href="#MJX-2-TEX-N-2C"></use></g><g data-mml-node="mo" transform="translate(5224,0)"><use data-c="2E" xlink:href="#MJX-2-TEX-N-2E"></use></g><g data-mml-node="mo" transform="translate(5668.7,0)"><use data-c="2E" xlink:href="#MJX-2-TEX-N-2E"></use></g><g data-mml-node="mo" transform="translate(6113.3,0)"><use data-c="2E" xlink:href="#MJX-2-TEX-N-2E"></use></g><g data-mml-node="msub" transform="translate(6558,0)"><g data-mml-node="mi"><use data-c="1D44E" xlink:href="#MJX-2-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-2-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(7413.9,0)"><use data-c="2C" xlink:href="#MJX-2-TEX-N-2C"></use></g><g data-mml-node="msub" transform="translate(7858.6,0)"><g data-mml-node="mi"><use data-c="1D44E" xlink:href="#MJX-2-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-2-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(8936.8,0)"><use data-c="2B" xlink:href="#MJX-2-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(9937,0)"><use data-c="31" xlink:href="#MJX-2-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(10437,0)"><use data-c="2C" xlink:href="#MJX-2-TEX-N-2C"></use></g><g data-mml-node="msub" transform="translate(10881.7,0)"><g data-mml-node="mi"><use data-c="1D44E" xlink:href="#MJX-2-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-2-TEX-I-1D45B"></use></g></g><g data-mml-node="mo" transform="translate(11917.9,0)"><use data-c="29" xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg></mjx-container></div></div>
<p>线性表的特点如下：</p>
<ul>
<li>表中元素的个数有限</li>
<li>表中元素具有逻辑上的顺序性，表中元素有其先后次序</li>
<li>表中元素都是数据元素，每个元素都是单个元素</li>
<li>表中的数据元素类型相同，这意味着每个元素占有相同大小的存储空间</li>

</ul>
<!--线性表是一种逻辑结构，表示元素之间一对一的相邻关系，顺序表和链表是存储结构，两者是不同层面的概念，因此不要将其混淆-->
<h3 id='212线性表的基本操作'>2.1.2.线性表的基本操作</h3>
<p>一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可通过调用其基
本操作来实现。线性表的主要操作如下:
InitList(&amp;L):初始化表。构造一个空的线性表，
Length(L):求表长。返回线性表工的长度，即L中数据元素的个数,
LocateElem(L,e):按值查找操作。在表L中查找具有给定关键字值的元素。
GetElem(L,i):按位查找操作。获取表L中第1个位置的元素的值。
ListInsert(&amp;l,i,e):插入操作。在表L中的第1个位置上插入指定元素e。
ListDelete(&amp;l,i,se):删除操作。删除表L中第1个位置的元素，并用e返回删除元素的值
PrintList(L):输出操作。按前后顺序输出线性表工的所有元素值。
Empty(L):判空操作。若L为空表，则返回true，否则返回false,
DestroyList(&amp;L):销毁操作。销毁线性表，并释放线性表L所占用的内存空间,
注意:①基本操作的实现取决于采用哪种存储结构，存储结构不同，算法的实现也
不同，②“&amp;”表示C++中的引用调用，若传入的变量是指针型变量，且在函数体内要对
传入的指针进行改变，则会用到指针变量的引用型，在C中采用指针的指针也可达到同样
的效果,</p>
<h3 id='213线性表的顺序表示'>2.1.3线性表的顺序表示</h3>
<h4 id='1）顺序表的定义'>（1）顺序表的定义</h4>
<p>线性表的顺序存储又称为顺序表。它是用一组地址连续的存储单元依次储存线性表中的数据元素，从而使得逻辑上相邻的两个元素，在物理上位置上也相邻。</p>
<!--线性表的位序是从1开始，而数组中的元素的下标是从0开始-->
<h4 id='2）顺序表的实现-静态分配'>（2）顺序表的实现-静态分配</h4>
<pre><code class='language-c++' lang='c++'>#define MaxSize 10            //定义最大长度
typedef struct{                
    ElemType data[MaxSize];  //用静态的数组存储数据元素
    int length;              //顺序表当前的长度
}SqList;                     //顺序表的类型定义（静态分配方式）
</code></pre>
<h4 id='3）顺序表的实现-动态分配'>（3）顺序表的实现-动态分配</h4>
<pre><code class='language-c++' lang='c++'>#define InitSize 10      //顺序表的初始长度
typedef struct{          
    ElemType *data;      //只是动态分配数组的指针
    int MaxSize;         //顺序表的最大容量
    int length;          //顺序表当前长度
}SeqList;                //顺序表的类型定义
</code></pre>
<p><strong>key:</strong> 动态申请和释放内存空间</p>
<p>——malloc、free函数</p>
<p>		L.data=(ElemType * )malloc(sizeof(elemType) * InitSize);<!--malloc函数返回一个指针，需要强制类型转换为自己定义的数据元素类型指针--></p>
<p>&nbsp;</p>
<h4 id='4）基本操作'>（4）基本操作</h4>
<h5 id='initlistsqlist-l静态'>InitList(SqList &amp;L)静态</h5>
<pre><code class='language-c++' lang='c++'>void InitList(SqList &amp;L){       //初始化一个顺序表
	for(int i=o;i&lt;MaxSize;i++)
		L.data[i]=0;
	L.length=0;
}
</code></pre>
<h5 id='initlistseqlist-l动态'>InitList(SeqList &amp;L)动态</h5>
<pre><code class='language-c++' lang='c++'>void InitList(SeqList &amp;L){      //动态初始化一个顺序表
    L.data=(int*)malloc(sizeof(int)*InitSize);
    L.length=0;
    L.MaxSize=L.InitSize;
}
</code></pre>
<h5 id='increasesizeseqlist-lint-len'>IncreaseSize(SeqList &amp;L,int len)</h5>
<pre><code class='language-c++' lang='c++'>void IncreaseSize(SeqList &amp;L,int len){    //增加动态数组长度
    int *p=int *data;
    L.data=(int*)malloc((L.MaxSize+len)*sizeof(int));
    for(int i=0;i&lt;MaxSize;i++)
        L.data[i]=p[i];
    L.MaxSize=L.MaxSzie+len;
    free(p); 
}
</code></pre>
<h5 id='listinsertlie'>ListInsert(&amp;L,i,e)</h5>
<pre><code class='language-c++' lang='c++'>bool ListInsert(SqList &amp;L,int i,int e){        //顺序表的插入
    if(i&lt;1||i&gt;L.length+1)       //判断i的范围是否有效
        return false;
    if(L.length&gt;=MaxSize)      //当前存储空间已满，不能插入
        return false;
    for(int j=L.length;j&gt;=i;j--)//将第i个元素以及之后的元素后移
        L.data[j]=L.data[j-1]   
    L.data[i-1]=e;              //在位置i处放入e
    L.length++; //顺序表长度加1
    return true; 
}
</code></pre>
<p>最好的时间复杂度=O(1)</p>
<p>最坏的时间复杂度=O(n)</p>
<p>平均的时间复杂度=O(n)</p>
<h5 id='listdelete-lie'>ListDelete( &amp;L,i,e)</h5>
<pre><code class='language-c++' lang='c++'>bool ListDelete(SqList &amp;L,int i,int &amp;e){    //顺序的基本操作--删除
    if(i&lt;1||i&gt;L.length+1)       //判断i的范围是否有效
        return false;
    e=L.data[i-1];
    for(int j=i;j&lt;L.length;j++)
        L.data[j-1]=L.data[j];
    L.length--;
    return true;
}
</code></pre>
<p>最好的时间复杂度=O(1)</p>
<p>最坏的时间复杂度=O(n)</p>
<p>平均的时间复杂度=O(n)</p>
<h5 id='getelemli'>GetElem(L,i)</h5>
<pre><code class='language-c++' lang='c++'>ElemType GetElem(SqList L,int i){     //顺序表按位查找
	return L.data[i-1];
}
</code></pre>
<p>时间复杂度=O(1)</p>
<h5 id='locateelemle'>LocateElem(L,e)</h5>
<pre><code class='language-c++' lang='c++'>ElemType LocateElem(SqList L,int e)
    for(int i=0;i&lt;L.length;i++)
        if(L.data[i]==e)
            return i+1;
	return 0;
</code></pre>
<p>最好的时间复杂度=O(1)</p>
<p>最坏的时间复杂度=O(n)</p>
<p>平均的时间复杂度=O(n)</p>
<h4 id='5顺序表的特点'>（5)顺序表的特点</h4>
<ul>
<li>随机访问：即可以在O(1)时间内找到第i个元素</li>
<li>存储密度高：每个节点只存储数据元素</li>
<li>拓展容量不方便：要采用动态分配方式实现。拓展长度的时间复杂度也比较高</li>
<li>插入和删除操作不方便，需要移动大量的元素</li>
<li>缺点：要求大片连续空间，改变容量不方便</li>

</ul>
<h3 id='214线性表的链式表示'>2.1.4线性表的链式表示</h3>
<h4 id='1单链表'>(1)单链表</h4>
<h5 id='定义-1'>定义</h5>
<pre><code class='language-c++' lang='c++'>typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode,*LinkList;
</code></pre>
<!--**LNode *  L;//强调这是一个节点**-->
<!--**LinkList L；//强调这是一个单链表**-->
<!--**单链表是表头指针唯一确定的，所以单链表可以用头指针来命名，若是头指针名是L，则简称该链表是表L**-->
<p><!--**LNode *  p或LinkList p，那么p为指向某节点的指针变量，表示的是该结点的地址，而*p表示的是结点变量，表示该节点的名称-->**</p>
<h5 id='首元结点头结点头指针'>首元结点，头结点，头指针</h5>
<p>首元节点</p>
<div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n153" cid="n153" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="43.283ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 19131.2 950" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.452ex;"><defs><path id="MJX-3-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path><path id="MJX-3-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">首</text></g><g data-mml-node="mtext" transform="translate(825.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">元</text></g><g data-mml-node="mtext" transform="translate(1651.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">节</text></g><g data-mml-node="mtext" transform="translate(2477.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mtext" transform="translate(3302.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">是</text></g><g data-mml-node="mtext" transform="translate(4128.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">链</text></g><g data-mml-node="mtext" transform="translate(4954.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">表</text></g><g data-mml-node="mtext" transform="translate(5780.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">中</text></g><g data-mml-node="mtext" transform="translate(6605.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">存</text></g><g data-mml-node="mtext" transform="translate(7431.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">储</text></g><g data-mml-node="mtext" transform="translate(8257.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">数</text></g><g data-mml-node="mtext" transform="translate(9083.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">据</text></g><g data-mml-node="mtext" transform="translate(9909.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(10734.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">第</text></g><g data-mml-node="mtext" transform="translate(11559.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">一</text></g><g data-mml-node="mtext" transform="translate(12385.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(13211.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(14037.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(14862.7,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="825.5px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mtext" transform="translate(15687.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">通</text></g><g data-mml-node="mtext" transform="translate(16513.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">常</text></g><g data-mml-node="mtext" transform="translate(17339.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">是</text></g><g data-mml-node="msub" transform="translate(18165.7,0)"><g data-mml-node="mi"><use data-c="1D44E" xlink:href="#MJX-3-TEX-I-1D44E"></use></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><use data-c="31" xlink:href="#MJX-3-TEX-N-31"></use></g></g></g></g></svg></mjx-container></div></div>
<p>头结点</p>
<p>		头结点是在首元节点之前附设的一个节点，其指针域指向首元节点，数据与不存储任何数据信息，可存储与数据类型相同的其他附加信息。</p>
<p>头指针</p>
<p>		头指针指向链表中的第一个结点。</p>
<h5 id='链表增加头结点的作用'>链表增加头结点的作用</h5>
<ul>
<li><p>便于首元节点的处理
增加了头结点，那么首元节点的地址就保存在了头结点的指针域中，就和其它节点一样（有前驱了）</p>
</li>
<li><p>便于空表和非空表的统一处理
不设置头结点L应指向首元节点，当链表为空表时，L=null,设置头结点之后无论如何L都是非空，L-&gt;next=null时，链表才为空</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</li>

</ul>
<h5 id='初始化-1'>初始化</h5>
<pre><code class='language-c++' lang='c++'>bool InitList(LinkList L){//带头结点
    L=new LNode;
    L-&gt;next=null;
    return true;
}
bool Empty(LinkList L){//判断单链表是否为空
    return (L-&gt;next==null);
}

</code></pre>
<pre><code class='language-c++' lang='c++'>bool InitList(LinkList L){//不带头结点
    L=null;
    return true;
}
bool Empty(LinkList L){//判断单链表是否为空
    return (L==null);
}
</code></pre>
<h5 id='取值'>取值</h5>
<pre><code class='language-c++' lang='c++'>bool GetElem(LinkList L,int i,ElemType &amp;e){//带头结点的单链表L中根据序号i获取元素的值，用e返回第i个元素的值
    if(i&lt;1)
        return false;
    p=L-&gt;next;
    j=1;
    while(p&amp;&amp;j&lt;i){
        p=p-&gt;next;
        j++;
    }
    if(p==null)
        return false;
    e=p-&gt;data;
    return true;  
}
</code></pre>
<p>&nbsp;</p>
<h5 id='查找'>查找</h5>
<pre><code class='language-c++' lang='c++'>LNode* GetElem(LinkList L,int i){//按位查找第i个结点
    if (i&lt;1)
        return false;
    LNode *p;//表示当前扫描到的结点
    p=L;
    int j=0;//扫描结点的个数
    while(p!=null&amp;&amp;j&lt;i){//此循环用来找到插入节点前面一个结点
         p=p-&gt;next;
         j++;
    }
    return p;
}


LNode* GetElem(LinkList L,ElemTyp e){//按值查找
    if (i&lt;1)
        return false;
    LNode *p;//表示当前扫描到的结点
    p=L;
    int j=0;//扫描结点的个数
    while(p!=null&amp;&amp;p-&gt;data!=e){//此循环用来找到插入节点前面一个结点
         p=p-&gt;next;
    }
    return p;
}
</code></pre>
<p>&nbsp;</p>
<h5 id='插入-1'>插入</h5>
<pre><code class='language-c++' lang='c++'>bool ListInsert(LinkList &amp;L,int i,ElemType e){//带头结点在第i个位置插入值为e的结点
    if (i&lt;1)
        return false;
    LNode *p;//表示当前扫描到的结点
    p=L;
    int j=0;//扫描结点的个数
    while(p!=null&amp;&amp;j&lt;i-1){//此循环用来找到插入节点前面一个结点
         p=p-&gt;next;
         j++;
    }
     if(p==null){//当插入位置大于了此链表的节点数就会返回false
          return false
     }
   LNode * s=(LNode*)malloc(sizeof(LNode));
    s-&gt;data=e;
    s-&gt;next=p-&gt;next;
    p-&gt;next=s;
    return true;
   
}
</code></pre>
<pre><code class='language-c++' lang='c++'>bool ListInsert(LinkList &amp;L,int i,ElemType e){//不带头结点在第i个位置插入值为e的结点
    if (i&lt;1)
        return false;
    if(i==1){
        LNode *s=(LNode*)malloc(sizeof(LNode));
        s-&gt;data=e;
        s-&gt;next=null;
        L=s;
    }
    LNode *p;//表示当前扫描到的结点
    p=L;
    int j=1;//扫描结点的个数
    while(p!=null&amp;&amp;j&lt;i-1){//此循环用来找到插入节点前面一个结点
         p=p-&gt;next;
         j++;
    }
     if(p==null){//当插入位置大于了此链表的节点数就会返回false
          return false
     }
   LNode * s=(LNode*)malloc(sizeof(LNode));
    s-&gt;data=e;
    s-&gt;next=p-&gt;next;
    p-&gt;next=s;
    return true;
   
}
</code></pre>
<pre><code class='language-c++' lang='c++'>bool InsertNextNode(LNode *p,Elemtype e){//指定结点后插值为e的结点
    if(p=null)
        return false;
    LNode *s=(LNode*)malloc(sizeof(LNode));
    if(s==null)//内存分配失败
        return false;
    s-&gt;data=e;
    s-&gt;next=p-&gt;next;
    p-&gt;next=s;
 	return true; 
}
</code></pre>
<pre><code class='language-c++' lang='c++'> bool InsertNextNode(LNode *p,Elemtype e){//指定结点前插值为e的结点
    if(p=null)
        return false;
    LNode *s=(LNode*)malloc(sizeof(LNode));
    if(s==null)//内存分配失败
        return false;
    s-&gt;data=p-&gt;data;
    p-&gt;data=e;
    s-&gt;next=p-&gt;next;
    p-&gt;next=s;
 	return true; 
}
}
</code></pre>
<pre><code class='language-c++' lang='c++'> bool InsertNextNode(LNode *p,LNode *s){//指定结点p前插结点s
    if(p=null||s=null)
        return false;
    s-&gt;next=p-&gt;next;
    p-&gt;next=s;
    ElemType e=s-&gt;data;
    s-&gt;data=p-&gt;data;
    p-&gt;data=e;
 	return true; 
}
}
</code></pre>
<p>&nbsp;</p>
<h5 id='删除-1'>删除</h5>
<p>&nbsp;</p>
<pre><code class='language-c++' lang='c++'>bool DeleteNode(LNode *p){//删除指定结点p
    if(p=null)
        return false;
    LNode *q;
    q=p-&gt;next;
    p-&gt;data=q-&gt;data;
    p-&gt;next=q-&gt;next;
    free(q);
 	return true; 
}
}//如果删除的是最后一个结点就不适用了
//&lt;!--时间复杂度是O(1)--&gt;



bool DeleteNode(LNode *p){//删除指定结点p
    LNode *q;//表示当前扫描到的结点
    q=L;
    while(p!=null&amp;&amp;q-next!=p){//此循环用来找到插入节点前面一个结点
         q=q-&gt;next;
    }
  	q-next=p-next;
    free(p);
    return true;
   
}//&lt;!--时间复杂度是O(n)--&gt;
</code></pre>
<pre><code class='language-c++' lang='c++'>bool DeleteNode(LinkList &amp;L,int i){//删除第i个元素
    LNode *q;//表示当前扫描到的结点
    q=L;
    int j=0;//扫描结点的个数
    while(p!=null&amp;&amp;j&lt;i-1){//此循环用来找到插入节点前面一个结点
         p=p-&gt;next;
         j++;
    }
     if(p==null){//当插入位置大于了此链表的节点数就会返回false
          return false
     }
  	q-next=p-next;
    free(p);
    return true;
   
}//&lt;!--时间复杂度是O(n)--&gt;
</code></pre>
<h5 id='求表长'>求表长</h5>
<pre><code class='language-c++' lang='c++'>int Length(LinkList L){
    int len=0;
    LNode *p;
    p=L;
    while(p-&gt;next!=null){
        len++
    }
    return len;
}
</code></pre>
<h5 id='前插法创建单链表'>前插法创建单链表</h5>
<pre><code class='language-c++' lang='c++'>void CreateList(LinkList L,int n){
    L=new LNode;
    L-&gt;next=null;
    for(int i=0;i&lt;n;i++){
       p=new LNode;
       cin&gt;&gt;p-&gt;data;
       p-&gt;next=L-&gt;next;
       L-&gt;next=p-&gt;next;
    }
}
</code></pre>
<p>&nbsp;</p>
<h5 id='后插法创建单链表'>后插法创建单链表</h5>
<pre><code class='language-c++' lang='c++'>void CreateList(LinkList L,int n){
    L=new LNode;
    L-&gt;next=null;
    LNode *r=L;
    for(int i=0;i&lt;n;i++){
       p=new LNode;
       cin&gt;&gt;p-&gt;data;
       p-&gt;next=null;
       r-&gt;next=p;
        r=p;
    }
}
</code></pre>
<p>&nbsp;</p>
<h4 id='2双链表'>(2)双链表</h4>
<pre><code class='language-c++' lang='c++'>typedef struct DuLNode{
    ElemType data;
    struct DuNode *next,*prior;
}DuLNode,*DuLinkList;
</code></pre>
<h5 id='初始化-2'>初始化</h5>
<pre><code class='language-c++' lang='c++'>bool InitDuLNode(DuLinkList &amp;L){//初始化一个带头结点的双向链表
    L=(DuLNode*)malloc(sizeof(DuLNode));
    L-&gt;next=null;
    L-&gt;prior=null;
    return true;
}

bool Empty(DuLinkList L){
    return (L-&gt;next)
}
</code></pre>
<h5 id='插入-2'>插入</h5>
<pre><code class='language-c++' lang='c++'>bool InsertNextDuL(DuLNode *p,DuLNode *s){//在p结点后面插入s结点
    if(p==null||s==null)
        return false;
    s-&gt;next=p-&gt;next;
    if(p-&gt;next!=null)
        p-&gt;prior=s;
    p-&gt;next=s;
    s-&gt;prior=p;
    return true;
}
}
    
</code></pre>
<p>&nbsp;</p>
<h5 id='删除-2'>删除</h5>
<pre><code class='language-c++' lang='c++'>bool DeleteNextDuLnode(DuLNode *p){//删除p结点的后继节点
    if(p==null)
        return false;
    DuLNode *q=p-&gt;next;
    if(q==null)
        return false;
    p-&gt;next=q-&gt;next;
    if(q-&gt;next!=null)
        q-&gt;next-&gt;prior=p;
    free(q);
    return true;
}

void DestoryList(DuLNode &amp;L){
    while(L-&gt;next!=null)
     DeleteNextDuLnode(L);
    free(L);
    L=null;
}
</code></pre>
<p>&nbsp;</p>
<h5 id='遍历'>遍历</h5>
<pre><code class='language-c++' lang='c++'>while(p!=null)//后向遍历
    //对结点p做出相应的处理
    p=p-&gt;next;
  

while(p!=null)//前向遍历
    //对结点p做出相应的处理
    p=p-&gt;prior;


while(p-&gt;prior!=null)//前向遍历(跳过头结点)
    //对结点p做出相应的处理
    p=p-&gt;prior;

</code></pre>
<p>&nbsp;</p>
<h4 id='3循环链表'>(3)循环链表</h4>
<h5 id='循环单链表'>循环单链表</h5>
<pre><code class='language-c++' lang='c++'>typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode,*LinkList;


bool InitLNode(LinkList &amp;L){//初始化一个带头结点的循环链表
    L=(LNode*)malloc(sizeof(LNode));
    L-&gt;next=L;
    return true;
}

bool Empty(LinkList L){
    return (L-&gt;next==L)
}
</code></pre>
<h5 id='循环双链表'>循环双链表</h5>
<pre><code class='language-c++' lang='c++'>typedef struct DuLNode{
    ElemType data;
    struct DuNode *next，*prior;
}DuLNode,*DuLinkList;


bool InitDuLNode(DuLinkList &amp;L){//初始化一个循环双向链表
    L=(DuLNode*)malloc(sizeof(DuLNode));
    L-&gt;next=L;
    L-&gt;prior=L;
    return true;
}

bool Empty(DuLinkList L){
    return (L-&gt;next==L)
}
</code></pre>
<!--使用了循环链表，尾结点就可以和其他节点一样处理了-->
<h4 id='4静态链表'>(4)静态链表</h4>
<pre><code class='language-c++' lang='c++'>#define MaxSize 10
typedef struct{
    ElemType data;
    int next;
}SLinkList [MaxSize];
</code></pre>
<h4 id='5有序表的合并'>(5)有序表的合并</h4>
<h5 id='顺序有序表的合并'>顺序有序表的合并</h5>
<pre><code class='language-c++' lang='c++'>void MergeList_Sq(SqList LA,SqList LB,SqList &amp;LC){
    LC.length=LA.length+LB.length;
    LC.elem=new ElemType [LC.length]
    pc=LC.elem;
    pa=LA.elem;
    pa_last=LA.elem+LA.length-1;
    pb_last=LB.elem+LB.length-1;
    while(pa&lt;=pa_last&amp;&amp;pb&lt;pb_last){
        if(*pa&lt;=*pb)
            *pc++=*pa++;
        else
            *pc++=*pb++;
     while(pa&lt;=pa_last)
         *pc++=*pa++;
     while(pb&lt;=pb_last)
         *pc++=*pb++;
    }
}
</code></pre>
<h5 id='链式有序表的合并'>链式有序表的合并</h5>
<pre><code class='language-c++' lang='c++'>void MergeList_L(LinkList &amp;LA,LinkList &amp;LB,LinkList &amp;LC){
    pa=LA-&gt;next;
    pb=LB-&gt;next;
    pc=LC;
    while(pa&amp;&amp;pb){
        if(pa-&gt;data&lt;=pb-&gt;data){
            pc-&gt;next=pa;
            pc=pa;
            pa=pa-&gt;next; 
        }
        else{
            pc-&gt;next=pb;
            pc=pb;
            pb=pb-&gt;next;
        }
    }
     pc-next=pa?pa:pb;
        delect LB;
}
</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id='第三章栈和队列'>第三章栈和队列</h1>
<h2 id='31栈stack）'>3.1栈（Stack）</h2>
<p>是只允许在一端进行插入或者删除操作的线性表</p>
<p>特点：先进后出 Last in First out（LIFO）</p>
<h3 id='顺序栈'>顺序栈</h3>
<h4 id='定义与初始化-1'>定义与初始化</h4>
<pre><code class='language-c++' lang='c++'>//顺序栈的定义
#define MaxSize[10]
typedef struct{
    ElemType data[MaxSize];
    int top;
}SqStack;


//初始化栈
bool InitStack(SqStack &amp;S){//初始化栈顶指针
    S.top=-1;//这里面top指向的栈顶元素，如果top的初始值是0，那么top指向的就是栈顶元素的下一个元素
}

//栈的判空
bool StackEmpty(SqStack S){
    return(top=-1);
}
void testStack(){
    SqStacck S;//先声明再使用
    InitStack(&amp;S);
}
</code></pre>
<h4 id='进栈push'>进栈Push</h4>
<pre><code class='language-c++' lang='c++'>bool Push(SqStack &amp;S,ElemType e){
    if(S.top==MaxSize-1)//栈满
        return false;
    S.top=S.top+1;
    S.data[top]=e;
    return true;
}
</code></pre>
<h4 id='出栈pop'>出栈Pop</h4>
<pre><code class='language-c++' lang='c++'>bool Pop(SqStack &amp;S,ElemType e){
    if(S.top==-1)
        return false;
    e=S.data[S.top];
    S.top=S.top-1;
    return true;
}
</code></pre>
<h4 id='读栈顶元素'>读栈顶元素</h4>
<pre><code class='language-c++' lang='c++'>bool GetTop(SqStack S,ElemType &amp;e){
    if(S.top==-1)
        return false;
    e=S.data[S.top];
    return true;
}
</code></pre>
<h4 id='共享栈'>共享栈</h4>
<pre><code class='language-c++' lang='c++'>define MaxSize 10//共享栈的定义
tyepdef struct{
    ElemType data[MaxSize];
    int top0;
    int top1;
}

bool InitStack(){
    top0=-1;
    top1=MaxSize;
}

//栈满的条件是top0+1=top1；
</code></pre>
<h3 id='链栈'>链栈</h3>
<h4 id='定义与初始化-2'>定义与初始化</h4>
<pre><code class='language-c++' lang='c++'>typedef struct StrackNode{//栈的定义
    ElemType data;
    struct StrackNode *next;
}StrackNode,*LinkStrack;
</code></pre>
<h4 id='入栈'>入栈</h4>
<pre><code class='language-c++' lang='c++'>bool Push(LinkStrack &amp;S,ElemType e){
    p=new StrackNode;
    p-&gt;data=e;
    p-&gt;next=S;
    S=p;
    return true;
    
}
</code></pre>
<h4 id='出栈'>出栈</h4>
<pre><code class='language-c++' lang='c++'>bool Pop(LinkStrack &amp;S,ElemType e){
    if(S==null)
        return false;
    e=S-&gt;data;
    StrackNode *p;
    p=S;
    S=S-&gt;next;
    delete p;
    return true;
}
</code></pre>
<p>&nbsp;</p>
<h4 id='取栈顶元素'>取栈顶元素</h4>
<pre><code class='language-c++' lang='c++'>bool GetTop(LinkStrack S,ElemType e){
    if(S==null)
        return null;
    e=S-&gt;data;
    return true;
}
</code></pre>
<p>&nbsp;</p>
<h2 id='32队列'>3.2队列</h2>
<p>一端2插入一端删除的线性表。First in First out    (FIFO)</p>
<h3 id='循环队列顺序实现'>循环队列(顺序实现)</h3>
<p>为什么要实现循环的队列呢，其实主要原因是会出现假溢出的现象，如下图所示</p>
<figure><table>
<thead>
<tr><th>&nbsp;</th><th>&nbsp;</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead>
<tbody></tbody>
</table></figure>
<p>队头                                                                                                            队尾</p>
<p>此时由于队尾不能再继续插入元素，再插入元素就会出现数组下标越界的情况，但是队头却是空的，由此会出现假溢出的现象，此时使用循环队列就会十分恰当。</p>
<h4 id='定义与初始化-3'>定义与初始化</h4>
<pre><code class='language-c++' lang='c++'>dedine MaxSize 10//队列的定义
typedef struct{
    ElemType data[MaxSize];
    int front;
    int rear;
}SqQueue;

bool InitQueue(SqQueue &amp;Q){
    Q.front=Q.rear=0//注意，这里面rear指向的队尾元素的下一个元素，若是定义的时候，rear=MaxSize-1；此时，rear表示的是队尾元素，下面都采用rear表示队尾元素的下一个元素
}
</code></pre>
<p>&nbsp;</p>
<h4 id='入队-1'>入队</h4>
<pre><code class='language-c++' lang='c++'>bool EnQueue(SqQueue &amp;Q,ElemType e){
    if((Qrear+1)%MaxSize==Q.front)
        return false;
    Q.data[Q.rear]=e;
    Q.rear=(Q.rear+1)%MaxSize;
    return ture;
}
</code></pre>
<p>&nbsp;</p>
<h4 id='出队-1'>出队</h4>
<pre><code class='language-c++' lang='c++'>bool DeQueue(SqQueue &amp;Q,ElemType e){
    if(Q.front==Q.rear)
        return false;
    e=Q.data[Q.front];
    Q.front=(Q.front+1)%MaxSize;
    return true;
}
</code></pre>
<p>&nbsp;</p>
<h4 id='判断队列已满已空'>判断队列已满/已空</h4>
<pre><code class='language-c++' lang='c++'>bool QueueEnough(SqQueue &amp;Q){//判断队列已满
    return (Q.rear+1)%MaxSize==Q.front;
}


bool QueueEmpty(SqQueue &amp;Q){//判断队列已空
    return Q.front==Q.rear;
}
</code></pre>
<p>&nbsp;</p>
<h4 id='取队首元素'>取队首元素</h4>
<pre><code class='language-c++' lang='c++'>bool GetFront(SqQueue &amp;Q,ElemType e){
    if(Q.front==Q.rear)
        return false;
    e=Q.data[Q.front];
    return true;
}
</code></pre>
<p>&nbsp;</p>
<h4 id='不准浪费队列存储空间'>不准浪费队列存储空间</h4>
<p>其实上面所采用的方法是空出一个存储空间，来区分队列已满还是已空，假如出试卷的老师要求我们不准浪费存储空间，又该如何答题呢</p>
<ul>
<li>在定义队列的时候加上一个size变量，用来表示当前队列中的元素个数，当size=0，则表示空。当size=MaxSize，则表示满</li>
<li>当队列空的时候，那么队列上一次进行的操作一定是出队，反之满的时候应当是入队。那么在定义队列的时候，可以加上一个tag变量，当进行出队操作的时候tag=0，当入对的时候tag=1，即front==rear&amp;&amp;tag==0就表示空，front==rear&amp;&amp;tag==1就表示满</li>

</ul>
<p>&nbsp;</p>
<h3 id='链队'>链队</h3>
<h4 id='定义与初始化-4'>定义与初始化</h4>
<pre><code class='language-c++' lang='c++'> typedef struct QNode{//链表的初始化
     Elemtype data;
     struct QNode *next;
 }QNode,*QueuePtr;
typedef struct{
    QueuePtr front;
    QueuePtr rear;
}LinkQueue;


//初始化
bool InitQueue(LinkQueue &amp;Q,ElemType e){//带头结点
    Q.front=Q.rear=new QNode;
    Q.front-&gt;next=null;
    return true;
}

bool InitQueue(LinkQueue &amp;Q,ElemType e){//不带头结点
    Q.front=Q.rear=null;
    return true;
}
</code></pre>
<p>&nbsp;</p>
<h4 id='入队-2'>入队</h4>
<pre><code class='language-c++' lang='c++'>bool enqueue(LinkQueue &amp;Q,ElemType e){//带头结点
    p=new QNode;
    p-&gt;data=e;
    p-&gt;next=null;
    Q.rear-&gt;next=p;
    Q.rear=p;
    return true;
}

bool enqueue(LinkQueue &amp;Q,ElemType e){//不带头结点
    p=new QNode;
    p-&gt;data=e;
    p-&gt;next=null;
    if(Q.front==Q.rear){
        Q.front=p;
        Q.rear=p;
         return true;
    }
    else{
        Q.rear-&gt;next=p;
        Q.rear=p;
         return true;
    }
    
   
}
</code></pre>
<p>&nbsp;</p>
<h4 id='出队-2'>出队</h4>
<pre><code class='language-c++' lang='c++'>bool DuQueue(LinkQueue &amp;Q,ElemType &amp;e{//带头结点
    if(Q.front==Q.rear)
        return false;
    e=Q.front-&gt;next-data;
    LNode *p;
    p=Q.front-&gt;next;
    Q.front-&gt;next=p-&gt;next;
    if(p==Q.rear)
        Q.front=Q.rear;
    free (p);
    return true;
}
 
             
bool DuQueue(LinkQueue &amp;Q,ElemType &amp;e{//不带头结点
    if(Q.front==Q.rear)
        return false;
    LNode *p;
    p=Q.front;
    e=p-&gt;data;
    Q.front=p-&gt;next;
    if(p==Q.rear)
        Q.front=Q.rear=null;
    free (p);
    return true;
}            
</code></pre>
<p>&nbsp;</p>
<h4 id='取队头元素'>取队头元素</h4>
<pre><code class='language-c++' lang='c++'>bool GetTop(LinkQueue Q,ElemType e){//带头结点
    if(Q.front==Q.rear)
        return false;
    e=Q.front-&gt;next-&gt;data;
    return true;
}

bool GetTop(LinkQueue Q,ElemType e){//不带头结点
    if(Q.front==Q.rear)
        return false;
    e=Q.front-&gt;data;
    return true;
}
</code></pre>
<p>&nbsp;</p>
<h4 id='双端队列'>双端队列</h4>
<p>其实有一类题目考察的是输出序列合法性的</p>
<ul>
<li>栈：先进后出   队：先进先出   很容易</li>
<li>输入受限的双端队列：两端可以删除，一端能插入，也比较容易写</li>
<li>输出受限的双端队列：两端都可以插入，一端能删除，由于两个口都可以插入元素，所以要根据输出结果把比当前数字及以后的数逆序（一直到比当前数字大，或者数结束为止），然后看看能不能得到这样的输入，能得到就继续判断，一直到所有数字判断结束。</li>

</ul>
<p>&nbsp;</p>
<h2 id='33栈的应用'>3.3栈的应用</h2>
<h3 id='括号匹配机制'>括号匹配机制</h3>
<hr />
<p>&nbsp;</p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 191140.png" referrerpolicy="no-referrer"></p>
<p>&nbsp;</p>
<hr />
<h3 id='中缀表达式转后缀表达式手算）'>中缀表达式转后缀表达式（手算）</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 191320.png" referrerpolicy="no-referrer"></p>
<h3 id='中缀表达式转前缀表达式手算）'>中缀表达式转前缀表达式（手算）</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 191524.png" referrerpolicy="no-referrer"></p>
<h3 id='中缀表达式转后缀表达式机算基于栈实现）'>中缀表达式转后缀表达式（机算，基于栈实现）</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 191816.png" referrerpolicy="no-referrer"></p>
<pre><code class='language-c' lang='c'>
</code></pre>
<p>&nbsp;</p>
<h1 id='第四章--串'>第四章--串</h1>
<h2 id='串的定义'>串的定义</h2>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 152239.png" referrerpolicy="no-referrer"></p>
<p>&nbsp;</p>
<h2 id='串的比较操作'>串的比较操作</h2>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 152425.png" referrerpolicy="no-referrer"></p>
<p>&nbsp;</p>
<h2 id='串的存储结构'>串的存储结构</h2>
<h3 id='顺序存储'>顺序存储</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 160715.png" referrerpolicy="no-referrer"></p>
<p>&nbsp;</p>
<h3 id='链式存储'>链式存储</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 160854.png" referrerpolicy="no-referrer"></p>
<p>&nbsp;</p>
<h3 id='基于顺序存储实现基本操作'>基于顺序存储实现基本操作</h3>
<h4 id='substringsubsposlen'>SubString(&amp;Sub,s,pos,len)</h4>
<pre><code class='language-c' lang='c'>//用串Sub返回串S中从pos开始长度为len的子串
bool SubString(String &amp;Sub,String S,int pos,int len){
    if(pos+len-1&gt;S.length)
        return false;
    for(int i=pos;i&lt;=pos+len;i++){
        Sub.ch[i-pos-1]=S.ch[i];
    }
    Sub.length=len;
    return true;
} 

#define MaxSize 255
typedef struct{
    char ch [MaxSize];
    int length;
}String;
</code></pre>
<h4 id='strcomparest'>StrCompare(S,T)</h4>
<pre><code class='language-c' lang='c'>//比较操作，若是S&gt;T,则返回值&gt;0；若是S=T,则返回值=0；若S&lt;T,则返回值&lt;0
int StrCompare(String S,String T){
    for(int i=1;i&lt;=S.length&amp;&amp;i&lt;=T.length;i++){
        if(S.ch[i]!=T.ch[i])
            return S.ch[i]-T.ch[i];
    }
    return S.length-T.length;
}
</code></pre>
<h4 id='bf算法indexstpos'>BF算法Index(S,T,pos)</h4>
<pre><code class='language-c' lang='c'>//从pos开始查询，返回，模式串T,第一次出现的位置
int Index_BF(String S,String T,int pos){
    int i=pos;
    int j=1;
    while(i&lt;=S.length&amp;&amp;j&lt;=T.length){
        if(S.ch[i]==T.ch[j]){
            i++;
            j++;
        }
        else{
            i=i-j+2;
            j=1;
        }
    }
    if(j&gt;T.length) return i-T.length;
    else return 0;
}
</code></pre>
<p>&nbsp;</p>
<h4 id='kmp算法'>KMP算法</h4>
<pre><code class='language-c' lang='c'>//KMP算法
int Index_KMP(String S,String T,int pos){
    i=pos;
    j=1;
    while(i&lt;=S.length&amp;&amp;j&lt;=T.length){
        if(j==0||S.ch[i]==T.ch[j]){
            i++;
            j++;
        }
        else j=Next[j];
    }
    if(j&gt;T.length)return i-T.length;
    else return 0;
}

</code></pre>
<p>计算next函数值</p>
<p>其实就是求模式串的子串前缀以及后缀相等时的长度+1</p>
<pre><code class='language-c' lang='c'>//求Next数组
void get_next(String T,int next[]){
    i=1;
    next[0]=1;
    j=next[i];//这里面j保存的代表的其实是next[i]值，然后再结合下面的i++，就可以算出next[i+1]的值
    while(i&lt;=T.length){
        if(j==0||T.ch[i]==T.ch[j]){
            i++;
            j++;
            next[i]=j;//这里的i其实是i+1;
        }
        else j=next[j];
    }
}
</code></pre>
<p>计算next函数的修正值</p>
<figure><table>
<thead>
<tr><th>序号j</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead>
<tbody><tr><td>模式串</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>next[j]</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>nextval[j]</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>4</td></tr></tbody>
</table></figure>
<p>比如说j=3的时候，next[3]指向的j=1，这个时候j=1与j=3内容是一样的，我们就可以直接让nextval[3]=nextval[1]</p>
<pre><code class='language-c' lang='c'>void get_nextval(String T,int nextval[]){
    i=1;
    nextval[1]=0;
    j=nextval[i];
    while(i&lt;=T.length){
        if(j==0||T.ch[i]==T.ch[j]){
            i++;
            j++;
            if(T.ch[i]!=t.ch[j]){
                nextval[i]=j;
            }
            else
                nextval[i]=nextval[j];
        }
        else j=nextval[j];
    }
}
</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id='第五章-树和二叉树'>第五章-树和二叉树</h1>
<h2 id='51树和二叉树'>5.1树和二叉树</h2>
<h3 id='511树'>5.1.1树</h3>
<h4 id='树的定义'>树的定义</h4>
<p>是n（n&gt;=0）个结点的有限集，它或为空树或不为空树，对于非空树T:</p>
<ol start='' >
<li><p>有且仅有一个称为根节点的结点</p>
</li>
<li><p>除了根节点以外的其余节点可以分为m(m&gt;0)个互不相交的有限集T1，T2，....Tm,其中每一个集合又都是一棵树，称为根的子树（所以说，树是一种递归调用的结构）</p>
<p><strong>非空树的特点</strong></p>
</li>

</ol>
<ul>
<li>有且仅有一个根节点</li>
<li>没有后继的结点称为叶子节点</li>
<li>有后继的结点称为分支节点</li>
<li>除了根节点以外，任何一个节点都有且仅有一个前驱</li>
<li>每个节点可以有0或者多个后继</li>

</ul>
<h4 id='度'>度</h4>
<p>节点的度---有几个孩子</p>
<p>树的度------各节点的最大值</p>
<figure><table>
<thead>
<tr><th style='text-align:center;' >度为m的树</th><th style='text-align:center;' >m叉树</th></tr></thead>
<tbody><tr><td style='text-align:center;' >任意节点的度&lt;=m(最多有m个孩子)</td><td style='text-align:center;' >任意节点的度&lt;=m(最多有m个孩子)</td></tr><tr><td style='text-align:center;' >至少有一个结点度=m</td><td style='text-align:center;' >允许所有结点的度&lt;m</td></tr><tr><td style='text-align:center;' >一定是非空树，至少有m+1个结点</td><td style='text-align:center;' >可以是空树</td></tr></tbody>
</table></figure>
<h4 id='有序树无序树'>有序树，无序树</h4>
<p>有序树------从逻辑上看，树中的结点的各子树从左至右是有次序的，不能互换</p>
<p>无序树-----从逻辑上看，树中的结点的各子树从左至右是没有次序的，可以互换位置</p>
<h4 id='常见考点1'>常见考点1</h4>
<p>结点数=总度数+1</p>
<p>结点的度就是节点有几个孩子（分支）</p>
<h4 id='常考性质2'>常考性质2</h4>
<div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n442" cid="n442" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="73.255ex" height="2.557ex" role="img" focusable="false" viewBox="0 -880.4 32378.7 1130.4" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-4-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-4-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-4-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-4-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-4-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-4-TEX-N-2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path><path id="MJX-4-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">度</text></g><g data-mml-node="mtext" transform="translate(825.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(1651.9,0)"><use data-c="1D45A" xlink:href="#MJX-4-TEX-I-1D45A"></use></g><g data-mml-node="mtext" transform="translate(2529.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(3355,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">树</text></g><g data-mml-node="mtext" transform="translate(4180.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">第</text></g><g data-mml-node="mi" transform="translate(5006,0)"><use data-c="1D456" xlink:href="#MJX-4-TEX-I-1D456"></use></g><g data-mml-node="mtext" transform="translate(5351,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">层</text></g><g data-mml-node="mtext" transform="translate(6177,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">至</text></g><g data-mml-node="mtext" transform="translate(7002.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">多</text></g><g data-mml-node="mtext" transform="translate(7828,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="msup" transform="translate(8654,0)"><g data-mml-node="mi"><use data-c="1D45A" xlink:href="#MJX-4-TEX-I-1D45A"></use></g><g data-mml-node="mi" transform="translate(911,413) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-4-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(10081.1,0)"><use data-c="2212" xlink:href="#MJX-4-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(11081.3,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"></use></g><g data-mml-node="mtext" transform="translate(11581.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(12407.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(13233.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mo" transform="translate(14058.3,0)"><use data-c="28" xlink:href="#MJX-4-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(14447.3,0)"><use data-c="1D456" xlink:href="#MJX-4-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(15070.1,0)"><use data-c="2265" xlink:href="#MJX-4-TEX-N-2265"></use></g><g data-mml-node="mn" transform="translate(16125.9,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(16625.9,0)"><use data-c="29" xlink:href="#MJX-4-TEX-N-29"></use></g><g data-mml-node="mi" transform="translate(17014.9,0)"><use data-c="1D45A" xlink:href="#MJX-4-TEX-I-1D45A"></use></g><g data-mml-node="mtext" transform="translate(17892.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">叉</text></g><g data-mml-node="mtext" transform="translate(18718.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">树</text></g><g data-mml-node="mtext" transform="translate(19544.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">第</text></g><g data-mml-node="mi" transform="translate(20369.9,0)"><use data-c="1D456" xlink:href="#MJX-4-TEX-I-1D456"></use></g><g data-mml-node="mtext" transform="translate(20714.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">层</text></g><g data-mml-node="mtext" transform="translate(21540.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">至</text></g><g data-mml-node="mtext" transform="translate(22366.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">多</text></g><g data-mml-node="mtext" transform="translate(23191.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="msup" transform="translate(24017.8,0)"><g data-mml-node="mi"><use data-c="1D45A" xlink:href="#MJX-4-TEX-I-1D45A"></use></g><g data-mml-node="mi" transform="translate(911,413) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-4-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(25445,0)"><use data-c="2212" xlink:href="#MJX-4-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(26445.2,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"></use></g><g data-mml-node="mtext" transform="translate(26945.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(27771.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(28597.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mo" transform="translate(29422.2,0)"><use data-c="28" xlink:href="#MJX-4-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(29811.2,0)"><use data-c="1D456" xlink:href="#MJX-4-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(30434,0)"><use data-c="2265" xlink:href="#MJX-4-TEX-N-2265"></use></g><g data-mml-node="mn" transform="translate(31489.7,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(31989.7,0)"><use data-c="29" xlink:href="#MJX-4-TEX-N-29"></use></g></g></g></svg></mjx-container></div></div>
<h4 id='常考性质3'>常考性质3</h4>
<div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n445" cid="n445" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="33.696ex" height="5.198ex" role="img" focusable="false" viewBox="0 -1529.7 14893.5 2297.7" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -1.738ex;"><defs><path id="MJX-5-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path><path id="MJX-5-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-5-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-5-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">高</text></g><g data-mml-node="mtext" transform="translate(825.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">度</text></g><g data-mml-node="mtext" transform="translate(1651.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(2477.8,0)"><use data-c="210E" xlink:href="#MJX-5-TEX-I-210E"></use></g><g data-mml-node="mtext" transform="translate(3053.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(3878.9,0)"><use data-c="1D45A" xlink:href="#MJX-5-TEX-I-1D45A"></use></g><g data-mml-node="mtext" transform="translate(4756.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">叉</text></g><g data-mml-node="mtext" transform="translate(5582.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">树</text></g><g data-mml-node="mtext" transform="translate(6408.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">至</text></g><g data-mml-node="mtext" transform="translate(7234.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">多</text></g><g data-mml-node="mtext" transform="translate(8059.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="mfrac" transform="translate(8885.8,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="msup"><g data-mml-node="mi"><use data-c="1D45A" xlink:href="#MJX-5-TEX-I-1D45A"></use></g><g data-mml-node="mi" transform="translate(911,363) scale(0.707)"><use data-c="210E" xlink:href="#MJX-5-TEX-I-210E"></use></g></g><g data-mml-node="mo" transform="translate(1590.5,0)"><use data-c="2212" xlink:href="#MJX-5-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(2590.7,0)"><use data-c="31" xlink:href="#MJX-5-TEX-N-31"></use></g></g><g data-mml-node="mrow" transform="translate(465.1,-686)"><g data-mml-node="mi"><use data-c="1D45A" xlink:href="#MJX-5-TEX-I-1D45A"></use></g><g data-mml-node="mo" transform="translate(1100.2,0)"><use data-c="2212" xlink:href="#MJX-5-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(2100.4,0)"><use data-c="31" xlink:href="#MJX-5-TEX-N-31"></use></g></g><rect width="3290.7" height="60" x="120" y="220"></rect></g><g data-mml-node="mtext" transform="translate(12416.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(13242.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(14068.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g></g></g></svg></mjx-container></div></div>
<h4 id='常考性质4'>常考性质4</h4>
<p>高度为h的m叉树至少有h个结点</p>
<p>高度为h的度为m的树至少有h-1+m个结点</p>
<h4 id='常考性质5'>常考性质5</h4>
<div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n451" cid="n451" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="54.204ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 23958.4 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-6-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-6-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-6-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path><path id="MJX-6-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-6-TEX-I-1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path><path id="MJX-6-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-6-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-6-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-6-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-6-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">具</text></g><g data-mml-node="mtext" transform="translate(825.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="mi" transform="translate(1651.9,0)"><use data-c="1D45B" xlink:href="#MJX-6-TEX-I-1D45B"></use></g><g data-mml-node="mtext" transform="translate(2251.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(3077.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(3903.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mtext" transform="translate(4728.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(5554,0)"><use data-c="1D45A" xlink:href="#MJX-6-TEX-I-1D45A"></use></g><g data-mml-node="mtext" transform="translate(6432,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">叉</text></g><g data-mml-node="mtext" transform="translate(7257.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">树</text></g><g data-mml-node="mtext" transform="translate(8083.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">最</text></g><g data-mml-node="mtext" transform="translate(8909.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">小</text></g><g data-mml-node="mtext" transform="translate(9734.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">高</text></g><g data-mml-node="mtext" transform="translate(10560.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">度</text></g><g data-mml-node="mtext" transform="translate(11386.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(12212.7,0)"><use data-c="1D459" xlink:href="#MJX-6-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(12510.7,0)"><use data-c="1D45C" xlink:href="#MJX-6-TEX-I-1D45C"></use></g><g data-mml-node="msub" transform="translate(12995.7,0)"><g data-mml-node="mi"><use data-c="1D454" xlink:href="#MJX-6-TEX-I-1D454"></use></g><g data-mml-node="mi" transform="translate(510,-150) scale(0.707)"><use data-c="1D45A" xlink:href="#MJX-6-TEX-I-1D45A"></use></g></g><g data-mml-node="mo" transform="translate(14176.5,0)"><use data-c="28" xlink:href="#MJX-6-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(14565.5,0)"><use data-c="1D45B" xlink:href="#MJX-6-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(15165.5,0)"><use data-c="28" xlink:href="#MJX-6-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(15554.5,0)"><use data-c="1D45A" xlink:href="#MJX-6-TEX-I-1D45A"></use></g><g data-mml-node="mo" transform="translate(16654.8,0)"><use data-c="2212" xlink:href="#MJX-6-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(17655,0)"><use data-c="31" xlink:href="#MJX-6-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(18155,0)"><use data-c="29" xlink:href="#MJX-6-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(18766.2,0)"><use data-c="2B" xlink:href="#MJX-6-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(19766.4,0)"><use data-c="31" xlink:href="#MJX-6-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(20266.4,0)"><use data-c="29" xlink:href="#MJX-6-TEX-N-29"></use></g><g data-mml-node="mtext" transform="translate(20655.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">向</text></g><g data-mml-node="mtext" transform="translate(21480.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">上</text></g><g data-mml-node="mtext" transform="translate(22306.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">取</text></g><g data-mml-node="mtext" transform="translate(23132.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">整</text></g></g></g></svg></mjx-container></div></div>
<h4 id='双亲表示法'>双亲表示法</h4>
<p>每个节点保存只想双亲的指针</p>
<p> <img src="C:\Users\84569\Pictures\屏幕截图 2021-07-28 221204.png" referrerpolicy="no-referrer"></p>
<p>优点：查找指定节点的双亲结点很方便，删除的不是叶子节点就很麻烦</p>
<p>缺点：查找指定的孩子只能从头遍历</p>
<h4 id='孩子表示法'>孩子表示法</h4>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-28 221604.png" referrerpolicy="no-referrer"></p>
<h4 id='孩子兄弟表示法'>孩子兄弟表示法</h4>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-28 221751.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-28 221807.png" referrerpolicy="no-referrer"></p>
<h3 id='512二叉树'>5.1.2二叉树</h3>
<h4 id='二叉树的定义-1'>二叉树的定义</h4>
<p>二叉树是n（n≥0）个结点的有限集合：</p>
<p> ① 或者为空二叉树，即n = 0。</p>
<p> ② 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树 又分别是一棵二叉树。 </p>
<p>特点：①每个结点至多只有两棵子树 ②左右子树不能颠倒（二叉树是有序树）</p>
<h4 id='特殊的二叉树'>特殊的二叉树</h4>
<h5 id='满二叉树'>满二叉树</h5>
<div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n470" cid="n470" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="41.069ex" height="2.497ex" role="img" focusable="false" viewBox="0 -903.7 18152.3 1103.7" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.452ex;"><defs><path id="MJX-7-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path><path id="MJX-7-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-7-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-7-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">一</text></g><g data-mml-node="mtext" transform="translate(825.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">棵</text></g><g data-mml-node="mtext" transform="translate(1651.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">树</text></g><g data-mml-node="mtext" transform="translate(2477.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(3302.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">高</text></g><g data-mml-node="mtext" transform="translate(4128.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">度</text></g><g data-mml-node="mtext" transform="translate(4954.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(5780.7,0)"><use data-c="210E" xlink:href="#MJX-7-TEX-I-210E"></use></g><g data-mml-node="mi" transform="translate(6356.7,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="825.5px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mtext" transform="translate(7181.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">且</text></g><g data-mml-node="mtext" transform="translate(8007.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">含</text></g><g data-mml-node="mtext" transform="translate(8833.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="msup" transform="translate(9659.7,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-7-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(533,413) scale(0.707)"><use data-c="210E" xlink:href="#MJX-7-TEX-I-210E"></use></g></g><g data-mml-node="mo" transform="translate(10872.2,0)"><use data-c="2212" xlink:href="#MJX-7-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(11872.4,0)"><use data-c="31" xlink:href="#MJX-7-TEX-N-31"></use></g><g data-mml-node="mtext" transform="translate(12372.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(13198.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(14024.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mtext" transform="translate(14849.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(15674.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">二</text></g><g data-mml-node="mtext" transform="translate(16500.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">叉</text></g><g data-mml-node="mtext" transform="translate(17326.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">树</text></g></g></g></svg></mjx-container></div></div>
<p>特点：</p>
<ol start='' >
<li><p>只有最后一层有叶子节点</p>
</li>
<li><p>不存在度为 1 的结点</p>
</li>
<li><p>按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩 子为 2i+1；结点 i 的父节点为 i/2 向下取整（如果有的话）</p>
<p> </p>
</li>

</ol>
<h5 id='完全二叉树'>完全二叉树</h5>
<p>当且仅当其每一个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树</p>
<p>特点</p>
<ul>
<li><p>只有最后两层可能有叶子结点 </p>
</li>
<li><p>最多只有一个度为1的结点 </p>
</li>
<li><p>同左③ </p>
</li>
<li><p>i≤ n/2 向下取整为分支结点， i&gt; n/2向下取整 为叶子结点</p>
<h5 id='常见考点'>常见考点</h5>
<div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n493" cid="n493" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="50.958ex" height="2.497ex" role="img" focusable="false" viewBox="0 -903.7 22523.3 1103.7" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.452ex;"><defs><path id="MJX-8-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path><path id="MJX-8-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-8-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-8-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">高</text></g><g data-mml-node="mtext" transform="translate(825.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">度</text></g><g data-mml-node="mtext" transform="translate(1651.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(2477.8,0)"><use data-c="210E" xlink:href="#MJX-8-TEX-I-210E"></use></g><g data-mml-node="mtext" transform="translate(3053.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(3878.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">完</text></g><g data-mml-node="mtext" transform="translate(4704.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">全</text></g><g data-mml-node="mtext" transform="translate(5530.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">二</text></g><g data-mml-node="mtext" transform="translate(6356.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">叉</text></g><g data-mml-node="mtext" transform="translate(7182.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">树</text></g><g data-mml-node="mtext" transform="translate(8008.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">至</text></g><g data-mml-node="mtext" transform="translate(8834.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">少</text></g><g data-mml-node="mtext" transform="translate(9659.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="msup" transform="translate(10485.6,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-8-TEX-N-32"></use></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="210E" xlink:href="#MJX-8-TEX-I-210E"></use></g><g data-mml-node="mo" transform="translate(576,0)"><use data-c="2212" xlink:href="#MJX-8-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(1354,0)"><use data-c="31" xlink:href="#MJX-8-TEX-N-31"></use></g></g></g><g data-mml-node="mtext" transform="translate(12379.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(13205.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(14031.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mtext" transform="translate(14856.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">至</text></g><g data-mml-node="mtext" transform="translate(15682.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">多</text></g><g data-mml-node="mtext" transform="translate(16507.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="msup" transform="translate(17333.5,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-8-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(533,413) scale(0.707)"><use data-c="210E" xlink:href="#MJX-8-TEX-I-210E"></use></g></g><g data-mml-node="mo" transform="translate(18546.1,0)"><use data-c="2212" xlink:href="#MJX-8-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(19546.3,0)"><use data-c="31" xlink:href="#MJX-8-TEX-N-31"></use></g><g data-mml-node="mtext" transform="translate(20046.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(20872.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(21698.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g></g></g></svg></mjx-container></div></div>
</li>

</ul>
<h5 id='二叉排序树'>二叉排序树</h5>
<p>二叉排序树。一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p>
<ul>
<li>左子树上所有结点的关键字均小于根结点的关键字；</li>
<li>右子树上所有结点的关键字均大于根结点的关键字。 左子树和右子树又各是一棵二叉排序树。</li>

</ul>
<h5 id='平衡二叉树'>平衡二叉树</h5>
<p>树上任一结点的左子树和右子树的深度之差不超过1</p>
<h4 id='常考性质1'>常考性质1</h4>
<p>设非空二叉树中度为0，1，2结点个数分别为n0，n1，n2，n0=n2+1(叶子节点比二分支结点多一个)</p>
<p>假设树中的结点总数为n，则</p>
<p>①n=n0+n1+n2</p>
<p>②n=n1+2n2</p>
<h4 id='常见考点2'>常见考点2</h4>
<div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n509" cid="n509" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="73.058ex" height="2.444ex" role="img" focusable="false" viewBox="0 -880.4 32291.5 1080.4" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.452ex;"><defs><path id="MJX-9-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-9-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-9-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-9-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-9-TEX-N-2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path><path id="MJX-9-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">二</text></g><g data-mml-node="mtext" transform="translate(825.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">叉</text></g><g data-mml-node="mtext" transform="translate(1651.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">树</text></g><g data-mml-node="mtext" transform="translate(2477.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">第</text></g><g data-mml-node="mi" transform="translate(3302.9,0)"><use data-c="1D456" xlink:href="#MJX-9-TEX-I-1D456"></use></g><g data-mml-node="mtext" transform="translate(3647.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">层</text></g><g data-mml-node="mtext" transform="translate(4473.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">至</text></g><g data-mml-node="mtext" transform="translate(5299.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">多</text></g><g data-mml-node="mtext" transform="translate(6124.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="msup" transform="translate(6950.8,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-9-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(533,413) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-9-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(8000,0)"><use data-c="2212" xlink:href="#MJX-9-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(9000.2,0)"><use data-c="31" xlink:href="#MJX-9-TEX-N-31"></use></g><g data-mml-node="mtext" transform="translate(9500.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(10326.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(11152.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(11977.2,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="825.5px" font-family="serif" font-style="italic">（</text></g><g data-mml-node="mi" transform="translate(12927.1,0)"><use data-c="1D456" xlink:href="#MJX-9-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(13549.8,0)"><use data-c="2265" xlink:href="#MJX-9-TEX-N-2265"></use></g><g data-mml-node="mn" transform="translate(14605.6,0)"><use data-c="31" xlink:href="#MJX-9-TEX-N-31"></use></g><g data-mml-node="mi" transform="translate(15105.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="825.5px" font-family="serif" font-style="italic">）</text></g><g data-mml-node="mi" transform="translate(15930.7,0)"><use data-c="1D45A" xlink:href="#MJX-9-TEX-I-1D45A"></use></g><g data-mml-node="mtext" transform="translate(16808.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">叉</text></g><g data-mml-node="mtext" transform="translate(17634.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">树</text></g><g data-mml-node="mtext" transform="translate(18460.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">第</text></g><g data-mml-node="mi" transform="translate(19285.7,0)"><use data-c="1D456" xlink:href="#MJX-9-TEX-I-1D456"></use></g><g data-mml-node="mtext" transform="translate(19630.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">层</text></g><g data-mml-node="mtext" transform="translate(20456.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">至</text></g><g data-mml-node="mtext" transform="translate(21282.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">多</text></g><g data-mml-node="mtext" transform="translate(22107.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="msup" transform="translate(22933.6,0)"><g data-mml-node="mi"><use data-c="1D45A" xlink:href="#MJX-9-TEX-I-1D45A"></use></g><g data-mml-node="mi" transform="translate(911,413) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-9-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(24360.8,0)"><use data-c="2212" xlink:href="#MJX-9-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(25361,0)"><use data-c="31" xlink:href="#MJX-9-TEX-N-31"></use></g><g data-mml-node="mtext" transform="translate(25861,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(26687,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(27512.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(28338,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="825.5px" font-family="serif" font-style="italic">（</text></g><g data-mml-node="mi" transform="translate(29287.8,0)"><use data-c="1D456" xlink:href="#MJX-9-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(29910.6,0)"><use data-c="2265" xlink:href="#MJX-9-TEX-N-2265"></use></g><g data-mml-node="mn" transform="translate(30966.4,0)"><use data-c="31" xlink:href="#MJX-9-TEX-N-31"></use></g><g data-mml-node="mi" transform="translate(31466.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="825.5px" font-family="serif" font-style="italic">）</text></g></g></g></svg></mjx-container></div></div>
<h4 id='常见考点3'>常见考点3</h4>
<div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n512" cid="n512" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="91.92ex" height="2.61ex" role="img" focusable="false" viewBox="0 -903.7 40628.5 1153.7" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-10-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path><path id="MJX-10-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-10-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-10-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-10-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-10-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">高</text></g><g data-mml-node="mtext" transform="translate(825.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">度</text></g><g data-mml-node="mtext" transform="translate(1651.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(2477.8,0)"><use data-c="210E" xlink:href="#MJX-10-TEX-I-210E"></use></g><g data-mml-node="mtext" transform="translate(3053.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(3878.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">二</text></g><g data-mml-node="mtext" transform="translate(4704.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">叉</text></g><g data-mml-node="mtext" transform="translate(5530.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">树</text></g><g data-mml-node="mtext" transform="translate(6356.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">至</text></g><g data-mml-node="mtext" transform="translate(7182.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">多</text></g><g data-mml-node="mtext" transform="translate(8007.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="msup" transform="translate(8833.7,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-10-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(533,413) scale(0.707)"><use data-c="210E" xlink:href="#MJX-10-TEX-I-210E"></use></g></g><g data-mml-node="mo" transform="translate(10046.2,0)"><use data-c="2212" xlink:href="#MJX-10-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(11046.5,0)"><use data-c="31" xlink:href="#MJX-10-TEX-N-31"></use></g><g data-mml-node="mtext" transform="translate(11546.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(12372.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(13198.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mo" transform="translate(14023.4,0)"><use data-c="28" xlink:href="#MJX-10-TEX-N-28"></use></g><g data-mml-node="mtext" transform="translate(14412.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">满</text></g><g data-mml-node="mtext" transform="translate(15238.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">二</text></g><g data-mml-node="mtext" transform="translate(16064.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">叉</text></g><g data-mml-node="mtext" transform="translate(16890.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">树</text></g><g data-mml-node="mo" transform="translate(17716.2,0)"><use data-c="29" xlink:href="#MJX-10-TEX-N-29"></use></g><g data-mml-node="mtext" transform="translate(18105.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">高</text></g><g data-mml-node="mtext" transform="translate(18931.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">度</text></g><g data-mml-node="mtext" transform="translate(19757.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(20583,0)"><use data-c="210E" xlink:href="#MJX-10-TEX-I-210E"></use></g><g data-mml-node="mtext" transform="translate(21159,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(21984.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">完</text></g><g data-mml-node="mtext" transform="translate(22810.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">全</text></g><g data-mml-node="mtext" transform="translate(23636,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">二</text></g><g data-mml-node="mtext" transform="translate(24461.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">叉</text></g><g data-mml-node="mtext" transform="translate(25287.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">树</text></g><g data-mml-node="mtext" transform="translate(26113.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">至</text></g><g data-mml-node="mtext" transform="translate(26939.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">少</text></g><g data-mml-node="mtext" transform="translate(27764.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="msup" transform="translate(28590.8,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-10-TEX-N-32"></use></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="210E" xlink:href="#MJX-10-TEX-I-210E"></use></g><g data-mml-node="mo" transform="translate(576,0)"><use data-c="2212" xlink:href="#MJX-10-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(1354,0)"><use data-c="31" xlink:href="#MJX-10-TEX-N-31"></use></g></g></g><g data-mml-node="mtext" transform="translate(30484.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(31310.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(32136.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mtext" transform="translate(32961.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">至</text></g><g data-mml-node="mtext" transform="translate(33787.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">多</text></g><g data-mml-node="mtext" transform="translate(34612.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="msup" transform="translate(35438.7,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-10-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(533,413) scale(0.707)"><use data-c="210E" xlink:href="#MJX-10-TEX-I-210E"></use></g></g><g data-mml-node="mo" transform="translate(36651.2,0)"><use data-c="2212" xlink:href="#MJX-10-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(37651.5,0)"><use data-c="31" xlink:href="#MJX-10-TEX-N-31"></use></g><g data-mml-node="mtext" transform="translate(38151.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(38977.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(39803.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g></g></g></svg></mjx-container></div></div>
<h4 id='常见的考点4'>常见的考点4</h4>
<p>对于完全二叉树，可以由的结点数 n 推出度为0、1和2的结点个数为n0、n1和n2完全二叉树最多只有一个度为1的结点，即</p>
<p> n1=0或1 </p>
<p>n0 = n2 + 1      </p>
<p>n0 + n2 一定是奇数 </p>
<p>若完全二叉树有2k个（偶数）个结点，则 必有 n1=1， n0 = k， n2 = k-1 </p>
<p>若完全二叉树有2k-1个（奇数）个结点，则 必有 n1=0， n0 = k， n2 = k-1</p>
<h4 id='二叉树的顺序存储'>二叉树的顺序存储</h4>
<pre><code class='language-c++' lang='c++'> define MaxSize 10
 typedef TElemType SqBiTree [MaxSize];
SqBiTree bt;
</code></pre>
<h4 id='二叉树的链式存储'>二叉树的链式存储</h4>
<pre><code class='language-c++' lang='c++'>typedef struct BiTNode{
    ElemType data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;
//n个结点的二叉链表一共有n+1个空链域，这个可以用于构造线索二叉树
</code></pre>
<h4 id='中先后序遍历的递归算法'>中先后序遍历的递归算法</h4>
<pre><code class='language-c' lang='c'>//中序遍历的递归算法
void InOrderTraverse(BiTree T){
    if(T){
         InOrderTraverse(T-&gt;lchild);
    	 cout&lt;&lt;T-&gt;data;
         InOrderTraverse(T-&gt;rchild);
    }  
}
//先序便利的递归算法
void FirstTraverse(BiTree T){
    if(T){
         cout&lt;&lt;T-&gt;data;
         FirstTraverse(T-&gt;lchild);
         FirstTraverse(T-&gt;rchild);
    }  
}
//后序遍历的递归算法
void LastTraverse(BiTree T){
    if(T){
         LastTraverse(T-&gt;lchild);
         LastTraverse(T-&gt;rchild);
    	 cout&lt;&lt;T-&gt;data;    
    }  
}
</code></pre>
<h4 id='中先后序遍历的非递归算法'>中先后序遍历的非递归算法</h4>
<pre><code class='language-c' lang='c'>void InOrderTaverse(BiTree T){
    InitStack(S);
    p=T;
    q=new BiTNode;
    while(p||!StackEmpty(S)){
      if(p){
        Push(S,p);
        p=p-&gt;lchild;
    } 
      else{
          Pop(S,q);
          cout&lt;&lt;q-&gt;data;
          p=q-&gt;rchild;
      }
    }   
}

void FirstTaverse(BiTree T){
    InitStack(S);
    p=T;
    q=new BiTNode;
    while(p||!StackEmpty(S)){
      if(p){
        visit(p)
        Push(S,p);
        p=p-&gt;lchild;
    } 
      else{
          Pop(S,q);
          p=q-&gt;rchild;
      }
    }   
}
//算法思想是栈顶元素保存的一定是子树的根节点
//当一个节点没有孩子说明是叶子节点
//当一个结点的右孩子为空或者刚刚被访问过就可以访问根节点，也就是访问栈顶元素
//一定要在结尾处使得pre指向栈顶元素，因为在后序访问中根节点是最重要的
void LastTraverse(BiTree T){
    InitStack(s);
    p=T;//p是所遍历到的结点的位置
    pre;//pre是指向栈顶元素指针；
    q=new BiTNode;//用来保存出栈的元素；
    while(p||!StackEmpty(s)){
        if(p){
            push(S,p);
            pre=S.top;
            p=p-&gt;lchild;
        }
        else{
            p=pre-&gt;rchild;
            if(p==null){
                Pop(S,q);
                visit(q);
            
            if(pre-&gt;rchild==null||pre-&gt;rchild==q){
                Pop(S,q);
                pre=S.top
            }
            p=pre-&gt;rchild;
            }
        }
    }
    
}
</code></pre>
<h4 id='树的深度'>树的深度</h4>
<pre><code class='language-c' lang='c'>int TreeDepath(BiTree T){
    if(T==null){
        return 0;
    }
    else{
        int l= TreeDepath(T-&gt;lchild);
        int r= TreeDepath(T-&gt;rchild);
		return l&gt;r?l+1:r+1;
    }
    
}
</code></pre>
<h4 id='二叉树的层次遍历'>二叉树的层次遍历</h4>
<pre><code class='language-c' lang='c'>typedef struct BiTNode{
    char data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;
typedef struct QNode{
    BiTree *data;
    struct QNode *next;
}QNode
 typedef struct{
     QNode *front,*rear;
 }LinkQueue;


void Levelorder(BiTree T){
    LinkQueue Q;//创建队列
    InitQueue(Q);//初始化队列
    BiTree p;//保存出队的结点
    EnQueue(Q,T);
    while(!IsEmpty(Q)){
        DuQueue(Q,p);
        visit(p);
        if(p-&gt;lchild!=null)
           EnQueue(Q,p-&gt;lchild); 
        if(p-&gt;rchild!=null)
           EnQueue(Q,p-&gt;rchild); 
    }
}
</code></pre>
<h4 id='由遍序序列构造二叉树'>由遍序序列构造二叉树</h4>
<ul>
<li>前序+中序</li>
<li>后序+中序</li>
<li>层序+中序</li>

</ul>
<h4 id='先序遍历的顺序建立二叉链表'>先序遍历的顺序建立二叉链表</h4>
<pre><code class='language-c' lang='c'>void CreatBiTree(BiTree &amp;T){
    cin&gt;&gt;ch;
    if(ch==&quot;#&quot;) T=null;
    else{
        T=new BiTree;
        T-&gt;data=ch;
        CreatBiTree(T-&gt;lchild);
        CreatBiTree(T-&gt;rchild);
    }
}
</code></pre>
<h4 id='复制二叉树'>复制二叉树</h4>
<pre><code class='language-c' lang='c'>void Copy(BiTree T,BiTree &amp;NewT){
	if(T==null){
        NewT=null;
        return
    }
    else{
        NewT=new BiTree;
        NewT-&gt;data=T-&gt;data;
        Copy(T-&gt;lchild,NewT-&gt;lchild);
        Copy(T-&gt;rchild.NewT-&gt;child);
    }
        
}
</code></pre>
<h4 id='计算二叉树结点个数'>计算二叉树结点个数</h4>
<pre><code class='language-c' lang='c'>int NodeCount(BiTree T){
    if(T==null)
        return 0;
    else
        return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1;
}
</code></pre>
<h3 id='513线索二叉树'>5.1.3线索二叉树</h3>
<p>线索化的过程也就是在遍历的过程中修改空指针的过程，为了记录访问过程中的先后关系，我们使用pre指向刚刚访问的结点，使用p指向当前访问的结点。线索二叉树可以很方便的找到前驱和后继，也就是说，可以从任意结点处开始遍历二叉树。</p>
<h4 id='线索二叉树的存储结构'>线索二叉树的存储结构</h4>
<pre><code class='language-c' lang='c'>typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,rchild;
    int ltag;
    int rtag;
}ThreadNode,*ThreadTree; 
</code></pre>
<h4 id='土办法找到中序前驱'>土办法找到中序前驱</h4>
<pre><code class='language-c' lang='c'>BiTree *p;//指向当前结点
BiTree *pre;
BiTree *final;
void findpre(BiTree T){
    p=T;
    findpre(p-&gt;lchild);
    if(q==p)
        final=pre;
    else
        pre=p;
    findpre(p-&gt;rchild);
}
</code></pre>
<p>&nbsp;</p>
<h4 id='中序线索二叉树'>中序线索二叉树</h4>
<pre><code class='language-c' lang='c'>//全局变量pre，指向当前结点的前驱
ThreadNode *pre=null;
//中序线索二叉树T
void CreateInThread(ThreadTree T){
     pre=null;
    if(T){
        InThreade(T);
        pre-&gt;rchild=null;
        pre-&gt;rtag=1;
    }
 
}
void InThread(ThhreadTree T){
    if(T){
        InThread(p-&gt;lchild,pre);
        visit(T);
        InThread(p-&gt;rchild,pre);
        
    }
}
//先序线索二叉树T
//访问过左子树的时候会出现循环访问的情况，因为访问完根节点之后会再访问左孩子，左孩子要是为空，就会访问到他的前驱结点，就会返回到根节点，于是会出现循环的情况（主要原因是左孩子的前驱和根节点是同一个结点）
void CreateInThread(ThreadTree T){
     pre=null;
    if(T){
        PreThread(T);
        pre-&gt;rchild=null;
        pre-&gt;rtag=1;
    }
 
}
void PreThread(ThreadTree T){
    if(T!=null){
        visit(T);
        if(ltag==0)
            PreThread(T-&gt;lchild);
        PreThread(T-&gt;rchild)
    }
}
//后序线索二叉树T
//因为在访问完左子树以及右子树的时候才会访问根节点，所以右孩子一定是已经北方问过的
void CreateInThread(ThreadTree T){
     pre=null;
    if(T){
        PreThread(T);
        pre-&gt;rchild=null;
        pre-&gt;rtag=1;
    }
 
}
void PostThread(ThreadTree T){
    if(T!=null){
        PreThread(T-&gt;lchild);
        PreThread(T-&gt;rchild);
        visit(T);
    }
}

//visit函数
void visit(ThreadTree *p){
    if(p-&gt;lchild==null){//线索化前驱
            p-&gt;lchild=pre;
            p-&gt;ltag=1;
        }
        if(pre!=null&amp;&amp;p-&gt;rchild==null){//线索化后继
            pre-&gt;rchild=p;
            pre-&gt;rtag=1;
        }
    pre=p
}


</code></pre>
<h4 id='中序线索二叉树找后继'>中序线索二叉树找后继</h4>
<pre><code class='language-c' lang='c'>//找到中序线索二叉树中结点p的后继结点
ThreadNode *NextNode(ThreadNode *p){
    if(p-&gt;ltag==0){
        while(p-&gt;lchild){
            p=p-&gt;lchild;
    		return p;
        }
        } 
     else
         return p-&gt;rchild;
          
}
//对中序线索二叉树进行中序遍历
void Inorder(ThreadNode *T){
    for(ThreadNode *p=T;p!=null;p=NextNode(p)){
        visit(p);
    }
}
</code></pre>
<h4 id='中序线索二叉树找前驱'>中序线索二叉树找前驱</h4>
<pre><code class='language-c' lang='c'>ThreadNode *FomNextNode(ThreadNode *p){
    if(p-&gt;rtag==0){
        while(p-&gt;rchild){
            p=p-&gt;rchild;
            return p;
        }
    }
    else
        return p-&gt;lchild;
}
</code></pre>
<h3 id='514森林和二叉树转换'>5.1.4森林和二叉树转换</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-28 222043.png" referrerpolicy="no-referrer"></p>
<h3 id='515树森林的遍历'>5.1.5树、森林的遍历</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-28 222242.png" referrerpolicy="no-referrer"></p>
<h3 id='516二叉排序树'>5.1.6二叉排序树</h3>
<h4 id='二叉树的定义-2'>二叉树的定义</h4>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-28 222454.png" referrerpolicy="no-referrer"></p>
<h4 id='查找操作'>查找操作</h4>
<pre><code class='language-c' lang='c'>typedef struct BSTNode{
    int key;
    struct BSTNode *lchild,*rchild;
}BSTNode,BSTree;

BSTNodBST_Search(BSTree B,int key){
    while(B!=null&amp;&amp;key!=B-&gt;key){
        if(key&lt;B-&gt;key)
            B=B-&gt;lchild;
        else
            B=B-&gt;rchild;
    }
    return B;
}
</code></pre>
<p>&nbsp;</p>
<h4 id='插入操作'>插入操作</h4>
<pre><code class='language-c' lang='c'>//插入操作
int BST_Insert(BSTree &amp;T,int k){
    if(T==null){
         T=(BSTree)malloc(sizeof(BSTNode));
         T-&gt;key=k;
        T-&gt;lchild=T-&gt;rchild=null;
    }
      else if(T-&gt;key==k) 
          return 1;
   	  else if(T-&gt;key&lt;k)
          return BST_Insert(T-&gt;lchild,k);
      else if(T-&gt;key&gt;k)
          return BST_Insert(T-&gt;rchild,k);
}
//二叉树的构造
void Creat(BSTree &amp;T,int []str,int n){
    T=null;
    while(i&lt;n){
        BST_Insert(T,str[i]);
        i++;
    }
}
</code></pre>
<p>&nbsp;</p>
<h4 id='删除操作'>删除操作</h4>
<p>先搜索到目标结点</p>
<ul>
<li>若是该节点是叶子结点，直接删掉</li>
<li>若是该结点只有一课左子树或者右子树，则让该结点的子树成为该结点父结点的子树</li>
<li>若是左右两颗子树都有，那么就让该子树的直接后继（或者直接前驱）代替，然后删去这个直接后继（或者直接前驱）</li>

</ul>
<h4 id='查找效率分析-1'>查找效率分析</h4>
<p>O（n）</p>
<h3 id='517平衡二叉树avl'>5.1.7平衡二叉树(AVL)</h3>
<h4 id='定义-2'>定义</h4>
<p>树上任一结点的左子树和右子树的高度度之差不超过1</p>
<p>结点的平衡因子=左子树高-右子树高</p>
<p>平衡因子的值只可能是-1，0，1</p>
<h4 id='插入新结点后如何调整不平衡问题'>插入新结点后如何调整“不平衡”问题</h4>
<p>每次我们都调整最小的不哦平衡子树</p>
<h5 id='ll'>LL</h5>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 150309.png" referrerpolicy="no-referrer"></p>
<pre><code class='language-c' lang='c'>实现 A 向右下旋转， B向右上旋转：
其中 A是爹，B为左孩子，gA为A他爹
    只有左孩子才能右上旋
① A-&gt;lchild = B-&gt;rchild;
② B-&gt;rchild = A;
③ gA-&gt;lchild/rchild = B;
</code></pre>
<p>&nbsp;</p>
<h5 id='rr'>RR</h5>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 150347.png" referrerpolicy="no-referrer"></p>
<pre><code class='language-c' lang='c'>实现 A 向左下旋转， B 向左上旋转：
其中 A是爹，B为右孩子，gA为A他爹
    只有右孩子才能左上旋
① A-&gt;rchild = B-&gt;lchild; ② B-&gt;lchild = A;
③ gA-&gt;lchild/rchild =B;
</code></pre>
<p>&nbsp;</p>
<h5 id='lr'>LR</h5>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 150831.png" referrerpolicy="no-referrer"></p>
<p>&nbsp;</p>
<h5 id='rl'>RL</h5>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 150909.png" referrerpolicy="no-referrer"></p>
<h4 id='查找效率分析-2'>查找效率分析</h4>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 151118.png" referrerpolicy="no-referrer"></p>
<h3 id='518哈夫曼树'>5.1.8哈夫曼树</h3>
<h4 id='带权路径长度'>带权路径长度</h4>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 151216.png" referrerpolicy="no-referrer"></p>
<h4 id='哈夫曼树的定义'>哈夫曼树的定义</h4>
<p>带权路径长度最小的二叉树称为哈夫曼树，也就是最优二叉树</p>
<h4 id='哈夫曼树的构造'>哈夫曼树的构造</h4>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 151344.png" referrerpolicy="no-referrer"></p>
<h4 id='哈夫曼编码'>哈夫曼编码</h4>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-07-29 151512.png" referrerpolicy="no-referrer"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<h1 id='第六章------图'>第六章——图</h1>
<h2 id='61图的基本概念'>6.1图的基本概念</h2>
<h3 id='图的定义'>图的定义</h3>
<p>图<em>G</em>由顶点集<em>V</em>和边集<em>E</em>组成，记为<em>G</em> = (<em>V</em>, <em>E</em>)，其中<em>V</em>(<em>G</em>)表示图<em>G</em>中顶点的有限非空集；<em>E</em>(<em>G</em>)表示图<em>G</em>中顶点之间的关系（边）集合。若<em>V</em> = {<em>v</em>1, <em>v</em>2, … , <em>v**n</em>}，则用|<em>V</em>|表示图<em>G</em>中顶点的数，也称图<em>G</em>的阶，<em>E</em> = {(<em>u</em>, <em>v</em>) | <em>u</em>Î<em>V</em>, <em>v</em>Î<em>V</em>}，用|<em>E</em>|表示图<em>G</em>中边的条数。 </p>
<p>注意：线性表可以是空表，树可以是空树，但图不可以是空，即V一定是非空集</p>
<h3 id='无向图有向图'>无向图有向图</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 103717.png" referrerpolicy="no-referrer"></p>
<h3 id='顶点的度入度出度'>顶点的度，入度，出度</h3>
<p>对于无向图：顶点<em>v</em>的度是指依附于该顶点的边的条数，记为TD(<em>v</em>)。</p>
<p>在具有<em>n</em>个顶点、<em>e</em>条边的无向图中，</p>
<p>即无向图的全部顶点的度的和等于边数的2倍 </p>
<p>对于有向图：</p>
<p>入度是以顶点<em>v</em>为终点的有向边的数目，记为ID(<em>v</em>)；</p>
<p>出度是以顶点<em>v</em>为起点的有向边的数目，记为OD(<em>v</em>)。</p>
<p>顶点<em>v</em>的度等于其入度和出度之和，即TD(<em>v</em>) = ID(<em>v</em>) + OD(<em>v</em>)。</p>
<p>在具有n个顶点，e条边的有向图里面，入度和=出度和=e</p>
<h3 id='顶点顶点的关系描述'>顶点~顶点的关系描述</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 104247.png" referrerpolicy="no-referrer"></p>
<h3 id='连通图强连通图'>连通图、强连通图</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 104442.png" referrerpolicy="no-referrer"></p>
<h3 id='子图生成子图'>子图、生成子图</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 110623.png" referrerpolicy="no-referrer"></p>
<h3 id='连通分量强连通分量'>连通分量、强连通分量</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 111108.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 111154.png" referrerpolicy="no-referrer"></p>
<h3 id='生成树生成森林'>生成树、生成森林</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 111359.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 111524.png" referrerpolicy="no-referrer"></p>
<h3 id='边的权带权图网'>边的权、带权图/网</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 111833.png" referrerpolicy="no-referrer"></p>
<h3 id='特殊图'>特殊图</h3>
<h4 id='无向完全图有向完全图'>无向完全图、有向完全图</h4>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 112133.png" referrerpolicy="no-referrer"></p>
<p>&nbsp;</p>
<h4 id='稀疏图稠密图'>稀疏图，稠密图</h4>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 112210.png" referrerpolicy="no-referrer"></p>
<h4 id='树和森林'>树和森林</h4>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 112414.png" referrerpolicy="no-referrer"></p>
<h3 id='总结'>总结</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 112502.png" referrerpolicy="no-referrer"></p>
<h2 id='62图的存储'>6.2图的存储</h2>
<h3 id='621邻接矩阵法'>6.2.1邻接矩阵法</h3>
<h4 id='不带权图'>不带权图</h4>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 135536.png" referrerpolicy="no-referrer"></p>
<p><strong>无向图</strong></p>
<p>第i个结点的度 = 第i行（或第i列）的非零元素个数</p>
<p><strong>有向图</strong></p>
<p>第i个结点的出度 = 第i行的非零元素个数</p>
<p>第i个结点的入度 = 第i列的非零元素个数</p>
<p>第i个结点的度 = 第i行、第i列的非零元素个数之和</p>
<h4 id='带权图'>带权图</h4>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 140249.png" referrerpolicy="no-referrer"></p>
<h4 id='特点'>特点</h4>
<p>O(|V|^2)——只和顶点数有关，和实际的边数无关</p>
<p>使用顺序存储（数组），空间复杂度高</p>
<p>适合用于存储稠密图</p>
<p>对称矩阵，可以用压缩矩阵存储</p>
<h4 id='邻接矩阵法的性质'>邻接矩阵法的性质</h4>
<div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n676" cid="n676" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="91.117ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 40273.6 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-11-TEX-I-1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path><path id="MJX-11-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-11-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path id="MJX-11-TEX-N-2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path><path id="MJX-11-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-11-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-11-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path><path id="MJX-11-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-11-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path><path id="MJX-11-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">设</text></g><g data-mml-node="mtext" transform="translate(825.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">图</text></g><g data-mml-node="mi" transform="translate(1651,0)"><use data-c="1D43A" xlink:href="#MJX-11-TEX-I-1D43A"></use></g><g data-mml-node="mtext" transform="translate(2437,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(3262.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">邻</text></g><g data-mml-node="mtext" transform="translate(4087.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">接</text></g><g data-mml-node="mtext" transform="translate(4913.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">矩</text></g><g data-mml-node="mtext" transform="translate(5739.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">阵</text></g><g data-mml-node="mtext" transform="translate(6565.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(7391,0)"><use data-c="1D434" xlink:href="#MJX-11-TEX-I-1D434"></use></g><g data-mml-node="mi" transform="translate(8141,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="825.5px" font-family="serif" font-style="italic">（</text></g><g data-mml-node="mtext" transform="translate(9090.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">矩</text></g><g data-mml-node="mtext" transform="translate(9916.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">阵</text></g><g data-mml-node="mtext" transform="translate(10742.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">元</text></g><g data-mml-node="mtext" transform="translate(11568.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">素</text></g><g data-mml-node="mtext" transform="translate(12394.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">为</text></g><g data-mml-node="mn" transform="translate(13220.5,0)"><use data-c="30" xlink:href="#MJX-11-TEX-N-30"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(13720.5,0)"><g data-mml-node="mo"><use data-c="2F" xlink:href="#MJX-11-TEX-N-2F"></use></g></g><g data-mml-node="mn" transform="translate(14220.5,0)"><use data-c="31" xlink:href="#MJX-11-TEX-N-31"></use></g><g data-mml-node="mi" transform="translate(14720.5,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="825.5px" font-family="serif" font-style="italic">）</text></g><g data-mml-node="mi" transform="translate(15545.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="825.5px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mtext" transform="translate(16370.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">则</text></g><g data-mml-node="msup" transform="translate(17195.9,0)"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-11-TEX-I-1D434"></use></g><g data-mml-node="mi" transform="translate(783,413) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-11-TEX-I-1D45B"></use></g></g><g data-mml-node="mtext" transform="translate(18453.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(19278.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">元</text></g><g data-mml-node="mtext" transform="translate(20104.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">素</text></g><g data-mml-node="msup" transform="translate(20930.1,0)"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-11-TEX-I-1D434"></use></g><g data-mml-node="mi" transform="translate(783,413) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-11-TEX-I-1D45B"></use></g></g><g data-mml-node="mo" transform="translate(22187.4,0)"><use data-c="5B" xlink:href="#MJX-11-TEX-N-5B"></use></g><g data-mml-node="mi" transform="translate(22465.4,0)"><use data-c="1D456" xlink:href="#MJX-11-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(22810.4,0)"><use data-c="5D" xlink:href="#MJX-11-TEX-N-5D"></use></g><g data-mml-node="mo" transform="translate(23088.4,0)"><use data-c="5B" xlink:href="#MJX-11-TEX-N-5B"></use></g><g data-mml-node="mi" transform="translate(23366.4,0)"><use data-c="1D457" xlink:href="#MJX-11-TEX-I-1D457"></use></g><g data-mml-node="mo" transform="translate(23778.4,0)"><use data-c="5D" xlink:href="#MJX-11-TEX-N-5D"></use></g><g data-mml-node="mtext" transform="translate(24056.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">等</text></g><g data-mml-node="mtext" transform="translate(24882.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">于</text></g><g data-mml-node="mtext" transform="translate(25708.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">由</text></g><g data-mml-node="mtext" transform="translate(26533.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">顶</text></g><g data-mml-node="mtext" transform="translate(27359.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(28184.4,0)"><use data-c="1D456" xlink:href="#MJX-11-TEX-I-1D456"></use></g><g data-mml-node="mtext" transform="translate(28529.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">到</text></g><g data-mml-node="mtext" transform="translate(29354.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">顶</text></g><g data-mml-node="mtext" transform="translate(30180.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(31005.6,0)"><use data-c="1D457" xlink:href="#MJX-11-TEX-I-1D457"></use></g><g data-mml-node="mtext" transform="translate(31417.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(32242.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">长</text></g><g data-mml-node="mtext" transform="translate(33068.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">度</text></g><g data-mml-node="mtext" transform="translate(33894.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(34720.5,0)"><use data-c="1D45B" xlink:href="#MJX-11-TEX-I-1D45B"></use></g><g data-mml-node="mtext" transform="translate(35320.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(36145.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">路</text></g><g data-mml-node="mtext" transform="translate(36971.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">径</text></g><g data-mml-node="mtext" transform="translate(37797.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(38622.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">数</text></g><g data-mml-node="mtext" transform="translate(39448.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">目</text></g></g></g></svg></mjx-container></div></div>
<p>&nbsp;</p>
<h4 id='创建无向网'>创建无向网</h4>
<pre><code class='language-c' lang='c'>#define MaxVertexNum 100
#define MaxInt 32767
typedef char VerTexType;
typedef int ArcType;
typedef struct{
    VerTexType vex[MaxVertexNum];//顶点表
    ArcType arc[MaxVertexNum][MaxVertexNum];//邻接矩阵
    int vexnum,arcnum;//顶点数和边数
}
Status CreateUDN(MGraph &amp;G){
    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;//输入总顶点数和总边数
    for(i=0;i&lt;G.vexnum;i++){//输入顶点信息
        cin&gt;&gt;vex[i];
    }
    for(i=0;i&lt;G.vexnum;i++)//初始化邻接矩阵
        for(j=0;j&lt;G.vexnum;j++){
            G.arc[i][j]=MaxInt;
        }
    for(k=0;k&lt;G.arcnum;k++){
        cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;
        i=LocateVex(G,v1);
        j=LocateVex(G,v2);
        G.arc[i][j]=w;
        G.arc[j][i]=G.arc[i][j];
    }
    return Ok;
}
//算法的时间复杂度是O(n^2)
</code></pre>
<p>&nbsp;</p>
<h3 id='622邻接表法'>6.2.2邻接表法</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 143940.png" referrerpolicy="no-referrer"></p>
<h4 id='创建无向图'>创建无向图</h4>
<pre><code class='language-c' lang='c'>//邻接表法的定义
#defin MVnum 100
//边/弧的信息
typedef struct ArcNode{
    int adjvex;//所指顶点的位置
    struct ArcNode *next;
}ArcNode;
//顶点信息
typedef struct VNode{
    VertexType data;
    ArcNode *first;
}VNOde,AdjList[MVnum];//用AdjList表示邻接表类型
//邻接表
typedef struct{
    AdjList vertices;
    int vexnum,arcnum;
}

//创建无向图
Status CreatUDG(ALGragh &amp;G){
    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;
    for(i=0;i&lt;G.vexnum;i++){//输入各点。构造表头元素
        cin&gt;&gt;G,vertices[i].data;//输入顶点值
        G.vertices[i].first=null;//构造表头元素，使表头元素指向null
        for(k=0;k&lt;G.arcnum;k++){
            cin&gt;&gt;v1&gt;&gt;v2;
            i=LocateVex(G,v1);
            j=LocateVex(G,v2);//确定i，j的位置
            p1=new ArcNode;//生成一个新的边结点*p1
            //下面是构建一个边结点j,把j插入到vi的边表的头部
            p1-&gt;adjvex=j;
            p1-&gt;next=G.vertices[i].first;
            G.vertices[i].first=p1;
           
            //相应的，要构建一个边结点i,把j插入到vj的边表的头部
             p2=new ArcNOde;//生成一个新的边结点*p2
             p2-&gt;adjvex=j;
             p2-&gt;next=G.vertices[j].first;
             G.vertices[j].first=p2;
        }
        return Ok;
    }
    //该算法的时间复杂度是O(n+e)
</code></pre>
<p>&nbsp;</p>
<h3 id='623十字链表'>6.2.3十字链表</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 150133.png" referrerpolicy="no-referrer"></p>
<p>空间复杂度：O(|V|+|E|)</p>
<p>如何找到指定顶点的所有出边？——顺着绿色线路找</p>
<p>如何找到指定顶点的所有入边？——顺着橙色线路找</p>
<p>注意：十字链表只用于存储有向图</p>
<h4 id='存储结构的定义'>存储结构的定义</h4>
<pre><code class='language-c' lang='c'>#define Max_Vertex_Num 20
//弧结点
typedef struct ArcNode{
    int tailvex,headvex;//该弧的尾和头顶点的位置
    struct ArcNode *tlink,*hlink;//分别为弧尾和弧头相同的弧的链域
    InfoType *info//该弧相关的信息的指针
}ArcNode
//顶点结点
typedef struct VexNode{
    VertexType data;
    ArcNode *firstin,*firstout;
}VexNode;
typedef struct{
    VexNode xlist[Max_Vertex_Num];
    int vexnum;
    int arcnum;
}OLGraph;
</code></pre>
<p>&nbsp;</p>
<h3 id='624邻接多重表'>6.2.4邻接多重表</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-01 151349.png" referrerpolicy="no-referrer"></p>
<p>空间复杂度：O(|V|+|E|) 每条边只对应一份数据</p>
<p>删除边、删除节点等操</p>
<p>作很方便</p>
<p>注意：邻接多重表只适</p>
<p>用于存储无向图</p>
<h2 id='63图的广度优先遍历bfs'>6.3图的广度优先遍历(BFS)</h2>
<p>注意：辅助队列谁先入队，是看的存储结构中谁在前，邻接矩阵是固定的，按照递增的方式，而邻接表是不固定的</p>
<h3 id='与树的广度优先遍历之间的联系'>与树的广度优先遍历之间的联系</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-02 114212.png" referrerpolicy="no-referrer"></p>
<h3 id='算法实现-1'>算法实现</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-02 114318.png" referrerpolicy="no-referrer"></p>
<pre><code class='language-c' lang='c'>//visit数组防止重复访问
    void BFS_Distance(Graph G,int u){
    cout&lt;&lt;u;
    visit[u]=true;
    InitQueue(Q);
    EnQueue(Q,u);
    while(!EmptyQueue(Q)){
        DuQueue(Q,u);                 for(w=FirstNeighbor(G,u);w&gt;0;w=NextNeighbor(G,u,w)){
            if(!visit[w]){
                visit[w]=true;
                EnQueue(Q,w);
            }
        }
    }
}
</code></pre>
<p>&nbsp;</p>
<h3 id='复杂度分析-1'>复杂度分析</h3>
<h4 id='空间复杂度-1'>空间复杂度</h4>
<p>空间复杂度最主要的就是对于辅助队列的存储</p>
<p>最坏的情况O(|V|)</p>
<h4 id='时间复杂度-1'>时间复杂度</h4>
<p>只考虑访问所有的结点和所有的边的时间就好了</p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-02 114721.png" referrerpolicy="no-referrer"></p>
<h3 id='广度优先生成树'>广度优先生成树</h3>
<p>广度优先生成树是由广度优先遍历过程确定的。由于邻接表的表示方式不唯一，因此基于邻接表的广度优先生成树也不唯一</p>
<h3 id='广度优先生成森林'>广度优先生成森林</h3>
<p><strong>对非连通图的⼴度优先遍历，可得到⼴度优先⽣成森林</strong></p>
<h2 id='64图的深度优先遍历dfs'>6.4图的深度优先遍历(DFS)</h2>
<h3 id='算法实现-2'>算法实现</h3>
<pre><code class='language-c' lang='c'>void DFSTraverse(Graph G){//深度优先遍历非连通图
    for(v=0;v&lt;G.vexnum;v++){//对visit数组进行初始化
        visit[v]=false;
    }
    for(v=0;i&lt;G.vexnum;v++){
        if(!visit[v])
            DFS(G,v);
    }
}
//FirstAdjVex(G,v)函数其实是指的图G中v的第一个邻接点
//NextAdjVex(G,v,w)函数其实是指图G中v相对于w的下一个邻接点
bool visit[MVnum];
void DFS(Graph G,int v){
    cout&lt;&lt;v;//访问v顶点
    visit[v]=true;//把标志位改成true
    for(w=FirstAdjVex(G,v);w&gt;0;w=NextAdjVex(G,v,w)){
        if(!visit[w])
            DFS(G,w);
    }
}
</code></pre>
<pre><code class='language-c' lang='c'>void DFS_AM(Graph G,int v){//邻接矩阵表示图的深度优先遍历算法
    cout&lt;&lt;v;//访问v顶点
    visit[v]=true;//把v顶点的状态设置为已读
    for(w=0;w&lt;G.vexnum;w++){
        if(!G.arc[v][w]&amp;&amp;!visit[w])
            DFS_AM(G,w);
    }
}
</code></pre>
<pre><code class='language-c' lang='c'>void DFS_AL(Graph G,int v){
    cout&lt;&lt;v;
    visit[v];
    p=G.vertices[v].firstarc//p指向第一个邻接点
    while(p){
        w=p-&gt;adjvex;//w指向p的顶点位置
        if(!visit[w])
            DFS_AL(G,w);
        p=p-&gt;nextarc;//p指向下一个边结点
    }
}
</code></pre>
<p>&nbsp;</p>
<h3 id='复杂度分析-2'>复杂//度分析</h3>
<h4 id='空间复杂度-2'>空间复杂度</h4>
<p>空间复杂度最主要的就是对于辅助队列的存储</p>
<p>最坏的情况O(|V|)</p>
<h4 id='时间复杂度-2'>时间复杂度</h4>
<p>只考虑访问所有的结点和所有的边的时间就好了</p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-02 114721.png" referrerpolicy="no-referrer"></p>
<h3 id='深度优先生成树'>深度优先生成树</h3>
<p>广度优先生成树是由广度优先遍历过程确定的。由于邻接表的表示方式不唯一，因此基于邻接表的广度优先生成树也不唯一</p>
<h3 id='深度优先生成森林'>深度优先生成森林</h3>
<p><strong>对非连通图的⼴度优先遍历，可得到深度优先生成森林</strong></p>
<p>&nbsp;</p>
<h2 id='65最小生成树'>6.5最小生成树</h2>
<p>连通图的生成树是包含图中的全部顶点的一个极小连通子图（顶点个数是n，则边数是n-1）</p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-02 161721.png" referrerpolicy="no-referrer"></p>
<p>1最⼩⽣成树可能有多个，但边的权值之和总是唯⼀且最⼩的 </p>
<p>2最⼩⽣成树的边数 = 顶点数 - 1。砍掉⼀条则不连通，增加⼀条边则会出现回路 </p>
<p>3如果⼀个连通图本身就是⼀棵树，则其最⼩⽣成树就是它本身 </p>
<p>4只有连通图才有⽣成树，⾮连通图只有⽣成森林</p>
<h3 id='prim算法普里姆'>Prim算法(普里姆)</h3>
<p>从某⼀个顶点开始构建⽣成树；每次将代价最⼩的新顶点纳⼊⽣成树，直到所有顶点都纳⼊为⽌。</p>
<pre><code class='language-c' lang='c'>struct{
    VexType adjvex;
    ArcType lowest;
} closedge[MVNum]
    
    
void MinSpanTree(AMGrame G,VexType u){
    k=located(G,u);//找到顶点u的数组下标位置
    for(j=0;j&lt;G.vexnum;j++){//初始化closedge数组
        if(j!=k)
            colsedge[j]={u,G.arcs[k][j]};
    }
    closedge[k].lowest=0;
    for(i=1;i&lt;G.vexnum;i++){//生成其余的n-1个结点
        k=Min{colsedge};
        u0=closedge[k].adjvex;
        v0=G.vexs[k];
        cout&lt;&lt;u0&lt;&lt;vo;
        colsedge[k].lowest=0;//把k并入U集
        for(j=0;j&lt;G.vexnum;j++){
            if(G.arcs[k][j]&lt;closedge[j].lowest)
                closedge[k]={G.vex[k],G.arcs[k][j]}
        }
    }
}
</code></pre>
<p>&nbsp;</p>
<h3 id='kruskal克鲁斯卡尔'>KrusKal(克鲁斯卡尔)</h3>
<p>每次选择⼀条权值最⼩的边，使这条边的两头连通（原本已经连通的就不选）直到所有结点都连通</p>
<pre><code class='language-c' lang='c'>
</code></pre>
<p>&nbsp;</p>
<h3 id='prim-算法-vs-kruskal-算法'>Prim 算法 v.s. Kruskal 算法</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-02 162956.png" referrerpolicy="no-referrer"></p>
<h2 id='66最短路径问题'>6.6最短路径问题</h2>
<h3 id='bfs算法'>BFS算法</h3>
<p>求无权图的单源最短路径 </p>
<p>增加两个数组d[]和path[]</p>
<p>d[]:存的是各个顶点到原始顶点路径长度</p>
<p>path[]:存的是每个顶点的直接前驱</p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-03 201723.png" referrerpolicy="no-referrer"></p>
<pre><code class='language-c' lang='c'>void BFS_Distance(Graph G,int u){
    for(i=0;i&lt;G.vexnum;i++){
        d[i]=∞；
        path[i]=-1;
    }
    d[u]=0
    visit[u]=true;
    EnQueue(Q,u);
    while(!EmptyQueue(Q)){
        DuQueue(Q,u);
        for(w=FirstNeighbor(G,u);w&gt;0;w=NextNeighbor(G,u,w)){
            if(!visit[w]){
                d[w]=d[u]+1;
                path[w]=u;
                visit[w]=true;
                EnQueue(Q,w);
            }
        }
    }
}
</code></pre>
<p>&nbsp;</p>
<h3 id='dijkstra算法'>Dijkstra算法</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-03 175511.png" referrerpolicy="no-referrer"></p>
<pre><code class='language-c' lang='c'>void DIJ(Graph G,int v0){
    for(v=0;v&lt;G.vexnum;v++){
        final[v]=false;
        dist[v]=G.arcs[v0][v];
        if(dist[v]&lt;Maxint)
            path[v]=v0;
        else
            path[v]=-1;
    }
    final[v]=true;
    dist[v]=0;
    /******到此初始化工作结束******/
    for(i=1;i&lt;G.vexnum;i++){
        min=Maxint
            for(w=0;w&lt;G.vexnum;w++){
                if(!final[w]&amp;&amp;dist[w]&lt;min){
                    v=w;
                    min=dist[w];
                }
                final[v]=ture;
                for(w=0;w&lt;G.vexnum;w++){
                    if(!final[w]&amp;&amp;(dist[v]+G.arcs[v][w])&lt;dist[w])
                  dist[w] =dist[v]+G.arcs[v][w];
                    path[w]=v;
                }
            }
    }
}
</code></pre>
<p>&nbsp;</p>
<h3 id='floyd算法'>Floyd算法</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-05 161855.png" referrerpolicy="no-referrer"></p>
<pre><code class='language-c' lang='c'>void Floyd(Graph G){
    for(i=0;i&lt;G.vexnum;i++)//初始化
        for(j=0;j&lt;G.vexnum;j++){
            A[i][j]=G.arcs[i][j];
            if(A[i][j]&lt;MaxInt&amp;&amp;i!=j)
                path[i][j]=i;
            else
                path[i][j]=-1;             
        }
    for(k=0;k&lt;G.vexnum;k++)//以vk为中转点
        for(i=o;i&lt;G.vexnum;i++)//遍历矩阵，i为行号,j为列号
            for(j=0;j&lt;G.vexnum;j++){
                if((A[i][k]+A[k][j])&lt;A[i][j]){
                    A[i][j]=A[i][k]+A[k][j];
                    path[i][j]=k;
                }
            }
}
</code></pre>
<h3 id='知识点回顾'>知识点回顾</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-03 204316.png" referrerpolicy="no-referrer"></p>
<h3 id='有向无环图dag描述表达式'>有向无环图(DAG)描述表达式</h3>
<p>有向⽆环图：若⼀个有向图中不存在环，则称为有向⽆环图，简称DAG图（Directed Acyclic Graph）</p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-03 205148.png" referrerpolicy="no-referrer"></p>
<h3 id='拓扑排序'>拓扑排序</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-05 163506.png" referrerpolicy="no-referrer"></p>
<pre><code class='language-c' lang='c'>void Topologic(Graph G){
    InitStack(S);
    for(i=0;i&lt;G.vexnum;i++)
       if(indegree[i]==0)
           Push(S,i)
    int count=0;
    while(!IsEmpty(S)){
        Pop(S,i);
        print[count++]=i
        p=G.vertices[i].firstarc;
        while(!p){
            k=p-&gt;adjvex;
            --indegree[k];
            if(indegree[k]==0)
                Push(S,k);
            p=p-&gt;nextarc;
        }
    }
    if(count&lt;G.vexnum)
        return false;
    else
        return true;
}
</code></pre>
<p>&nbsp;</p>
<h3 id='逆拓扑排序'>逆拓扑排序</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-05 200009.png" referrerpolicy="no-referrer"></p>
<h3 id='关键路径'>关键路径</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-05 200822.png" referrerpolicy="no-referrer"></p>
<ul>
<li><strong>若关键活动耗时增加，则整个工程的工期将增加</strong></li>
<li><strong>缩短关键活动的时间，可以缩短整个工程的工期</strong></li>
<li><strong>当缩短到⼀定程度时，关键活动可能会变成非关键活动</strong></li>
<li><strong>可能有多条关键路径，只提高⼀条关键路径上的关键活动速度并不能缩短整个⼯程的⼯期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短⼯期的目的。</strong></li>

</ul>
<pre><code class='language-c' lang='c'>
</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<h1 id='第七章------查找'>第七章——查找</h1>
<p><strong>查找 —— 在数据集合中寻找满⾜某种条件的数据元素的过程称为查找</strong> </p>
<p><strong>查找表（查找结构）—— ⽤于查找的数据集合称为查找表，它由同⼀类型的数据元素（或记录）组成</strong> </p>
<p><strong>关键字 —— 数据元素中唯⼀标识该元素的某个数据项的值，使⽤基于关键字的查找，查找结果应该是唯⼀的</strong></p>
<p><strong>查找⻓度——在查找运算中，需要对比关键字的次数称为查找⻓度</strong> </p>
<p><strong>平均查找⻓度（ASL, Average Search Length）—— 所有查找过程中进⾏关键字的⽐较次数的平均值</strong></p>
<h2 id='顺序查找'>顺序查找</h2>
<h3 id='算法思想'>算法思想</h3>
<p>顺序查找，⼜叫“线性查找”，通常⽤于线性表。 </p>
<p>算法思想：从头到 jio 挨个找（或者反过来也OK）</p>
<h3 id='算法实现-3'>算法实现</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-06 202130.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-06 202239.png" referrerpolicy="no-referrer"></p>
<h3 id='算法优化'>算法优化</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-06 202610.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-06 202748.png" referrerpolicy="no-referrer"></p>
<p>⼀个成功结点的查找⻓度 = ⾃身所在层数 </p>
<p>⼀个失败结点的查找⻓度 = 其⽗节点所在层数 </p>
<p>默认情况下，各种失败情况或成功情况都等概率发⽣</p>
<h2 id='折半查找'>折半查找</h2>
<p>又称“二分查找”，仅适用于有序的<strong>顺序表</strong>。</p>
<h3 id='算法实现-4'>算法实现</h3>
<pre><code class='language-c' lang='c'>typedef struct{
    ElemType *elem;
    int TableLen;
}SStable
int Binary_Search(SStable L,ElemType key){
    int low=0;
    int hight=L.TableLen-1;
    int mid;
    while(low&lt;=hight){
        mid=(low+hight)/2;
        if(L.elem[mid]==key)
            return mid;
        else(L.elem[mid]&lt;key)
            hight=mid-1;
        else
            low=low+1;
    }
    return -1;
}
</code></pre>
<p>&nbsp;</p>
<h3 id='查找判定树'>查找判定树</h3>
<div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n826" cid="n826" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="72.615ex" height="2.256ex" role="img" focusable="false" viewBox="0 -750 32096 997" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.559ex;"><defs><path id="MJX-12-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-12-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path><path id="MJX-12-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-12-TEX-I-1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path><path id="MJX-12-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">对</text></g><g data-mml-node="mtext" transform="translate(825.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">于</text></g><g data-mml-node="mtext" transform="translate(1651.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">长</text></g><g data-mml-node="mtext" transform="translate(2477.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">度</text></g><g data-mml-node="mtext" transform="translate(3303.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(4129.7,0)"><use data-c="1D45B" xlink:href="#MJX-12-TEX-I-1D45B"></use></g><g data-mml-node="mtext" transform="translate(4729.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(5554.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">有</text></g><g data-mml-node="mtext" transform="translate(6380.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">序</text></g><g data-mml-node="mtext" transform="translate(7206.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">表</text></g><g data-mml-node="mi" transform="translate(8032.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="825.5px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mtext" transform="translate(8857.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">折</text></g><g data-mml-node="mtext" transform="translate(9683.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">半</text></g><g data-mml-node="mtext" transform="translate(10509.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">查</text></g><g data-mml-node="mtext" transform="translate(11335.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">找</text></g><g data-mml-node="mtext" transform="translate(12161.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">在</text></g><g data-mml-node="mtext" transform="translate(12987.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">查</text></g><g data-mml-node="mtext" transform="translate(13813.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">找</text></g><g data-mml-node="mtext" transform="translate(14639.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">成</text></g><g data-mml-node="mtext" transform="translate(15465.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">功</text></g><g data-mml-node="mtext" transform="translate(16290.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(17116.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">给</text></g><g data-mml-node="mtext" transform="translate(17942.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">定</text></g><g data-mml-node="mtext" transform="translate(18767.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">值</text></g><g data-mml-node="mtext" transform="translate(19593.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">进</text></g><g data-mml-node="mtext" transform="translate(20419.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">行</text></g><g data-mml-node="mtext" transform="translate(21245.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">比</text></g><g data-mml-node="mtext" transform="translate(22071.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">较</text></g><g data-mml-node="mtext" transform="translate(22897,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(23722.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">关</text></g><g data-mml-node="mtext" transform="translate(24548,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">键</text></g><g data-mml-node="mtext" transform="translate(25374,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">字</text></g><g data-mml-node="mtext" transform="translate(26199.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">个</text></g><g data-mml-node="mtext" transform="translate(27025.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">数</text></g><g data-mml-node="mtext" transform="translate(27851.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">至</text></g><g data-mml-node="mtext" transform="translate(28677.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">多</text></g><g data-mml-node="mtext" transform="translate(29502.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="825.5px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(30328.8,0)"><use data-c="1D459" xlink:href="#MJX-12-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(30626.8,0)"><use data-c="1D45C" xlink:href="#MJX-12-TEX-I-1D45C"></use></g><g data-mml-node="msubsup" transform="translate(31111.8,0)"><g data-mml-node="mi"><use data-c="1D454" xlink:href="#MJX-12-TEX-I-1D454"></use></g><g data-mml-node="mi" transform="translate(510,413) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-12-TEX-I-1D45B"></use></g><g data-mml-node="mn" transform="translate(510,-247) scale(0.707)"><use data-c="32" xlink:href="#MJX-12-TEX-N-32"></use></g></g></g></g></svg></mjx-container></div></div>
<p><strong>如果当前low和high之间有奇数个元素，则mid 分隔后，左右两部分元素个数相等</strong></p>
<p><strong>如果当前low和high之间有偶数个元素，则 mid 分隔后，左半部分⽐右半部分少⼀个元素</strong></p>
<p><strong>折半查找的判定树中，若 ，则对于任何⼀个结点，必有：</strong></p>
<p><strong>右⼦树结点数左⼦树结点数=0或1</strong></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-06 205936.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-06 210043.png" referrerpolicy="no-referrer"></p>
<h3 id='折半查找效率'>折半查找效率</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-06 204925.png" referrerpolicy="no-referrer"></p>
<p>我们不能说折半查找的速度一定比顺序查找快，只能说绝大数的情况下。</p>
<h2 id='分块查找'>分块查找</h2>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-07 142115.png" referrerpolicy="no-referrer"></p>
<p>分块查找，⼜称索引顺序查找，算法过程如下： </p>
<p>①在索引表中确定待查记录所属的分块（可顺序、可折半） </p>
<p>②在块内顺序查找</p>
<p>索引表中不包含⽬标关键字，则折半查找索引表最终停在 low&gt;high，要在low所指分块中查找</p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-07 143314.png" referrerpolicy="no-referrer"></p>
<h2 id='b树-1'>B树</h2>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-07 193846.png" referrerpolicy="no-referrer"></p>
<p>关键字的值：⼦树0&lt;关键字1&lt;⼦树1&lt;关键字2&lt;⼦树2&lt;…. (类⽐⼆叉查找树 左&lt;中&lt;右)</p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-07 194726.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-07 211018.png" referrerpolicy="no-referrer"></p>
<h2 id='b树-2'>B+树</h2>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-07 213145.png" referrerpolicy="no-referrer"></p>
<p><strong>B+树中，⽆论查找成功与否，最终⼀定都要⾛到最下⾯⼀层结点</strong></p>
<p><strong>B树中查找成功，可能停在任何⼀层</strong></p>
<p><strong>在B+树中，叶结点包含信息，所有⾮叶结点仅起索引作⽤，⾮叶结点中的每个索引项只含有对应⼦树的最⼤关键字和指向该⼦树的指针，不含有该关键字对应记录的存储地址。</strong></p>
<p> <strong>B树的结点中都包含了关键字对应的记录的存储地址</strong></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-07 213954.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-07 213525.png" referrerpolicy="no-referrer"></p>
<h2 id='散列查找拉链法）'>散列查找（拉链法）</h2>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-08 080856.png" referrerpolicy="no-referrer"></p>
<p>装填因⼦α=表中记录数/散列表⻓度</p>
<p>装填因⼦会直接影响散列表的查找效率</p>
<h3 id='除留余数法'>除留余数法</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-08 081450.png" referrerpolicy="no-referrer"></p>
<h3 id='直接定址法'>直接定址法</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-08 081647.png" referrerpolicy="no-referrer"></p>
<h3 id='数字分析法'>数字分析法</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-08 081810.png" referrerpolicy="no-referrer"></p>
<h3 id='平方取中法'>平方取中法</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-08 081909.png" referrerpolicy="no-referrer"></p>
<p>散列查找是典型的“⽤空间换时间”的算法，只要散列函数设计的合理，则散列表越⻓，冲突的概率越低。</p>
<h2 id='散列查找开放定址法）'>散列查找（开放定址法）</h2>
<h3 id='线性探测法'>线性探测法</h3>
<p>所谓开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，⼜向它的⾮同义词表项开放。其数学递推公式为：Hi = (H(key) + di) % m </p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-08 082825.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-08 083111.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-08 085024.png" referrerpolicy="no-referrer"></p>
<p><strong>线性探测法很容易造成同义词、⾮同义词的聚集（堆积）现象，严重影响查找效率</strong></p>
<p><strong>产⽣原因——冲突后再探测⼀定是放在某个连续的位置</strong></p>
<h3 id='平方探测法'>平方探测法</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-08 090840.png" referrerpolicy="no-referrer"></p>
<p>⾮重点⼩坑：散列表⻓度<em>m</em>必须是⼀个可以表示成<em>4j + 3</em>的素数，才能探测到所有位置</p>
<h3 id='伪随机序列法'>伪随机序列法</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-08 090936.png" referrerpolicy="no-referrer"></p>
<h3 id='再散列法'>再散列法</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-08 091154.png" referrerpolicy="no-referrer"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<h1 id='第八章------排序'>第八章——排序</h1>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-08 101228.png" referrerpolicy="no-referrer"></p>
<h3 id='插入排序'>插入排序</h3>
<p>算法思想：每次将⼀个待排序的记录按其关键字⼤⼩插⼊到前⾯已排好序的⼦序列中，直到全部记录插⼊完成。</p>
<pre><code class='language-c' lang='c'>void INsertSort(int A[],int n){
    int i,j,temp;
    for(i=1;i&lt;n;i++){
        if(A[i]&lt;A[i-1]){
            temp=A[i];
       		for(j=i-1;j&gt;=0&amp;&amp;A[j]&gt;temp;j--)
            	A[j+1]=A[j];
        	A[j+1]=temp;
        }
    }
}
void INsertSort(int A[],int n){//带哨兵，不用每次判断A[j]&gt;=0
    int i,j
    for(i=2;i&lt;n;i++){
        if(A[i]&lt;A[i-1]){
            A[0]=A[i];
       		for(j=i-1;A[j]&gt;A[0];j--)
            	A[j+1]=A[j];
        	A[j+1]=A[0];
        }
    }
}

</code></pre>
<p>空间复杂度：O(1)</p>
<p>时间复杂度：主要来⾃对⽐关键字、移动元素 若有 n 个元素，则需要 n-1 趟处理</p>
<p>最好时间复杂度—— O(n)</p>
<p>最坏时间复杂度（全部逆序）：O(n2) </p>
<p>平均时间复杂度：O(n^2)</p>
<p>算法稳定性：稳定</p>
<p><strong>优化</strong></p>
<p>先⽤折半查找找到应该插⼊的位置，再移动元素</p>
<pre><code class='language-c' lang='c'>//当 low&gt;high 时折半查找停⽌，应将 [low, i-1] 内的元素全部右移，并将 A[0] 复制到 low 所指位置当 A[mid]==A[0] 时，为了保证算法的“稳定性”，应继续在 mid 所指位置右边寻找插⼊位置
void InsertSort(int A[],int n){
    int i,j,low,high,mid;
    for(i=2;i&lt;n;i++){
        A[0]=A[i];
        low=1;
        high=i-1;
        while(low&lt;=high){
            mid=(low+high)/2;
            if(A[mid]&gt;=A[0]) low=mid+1;
            else if high=mid-1;
        }
        for(j=i-1;j&gt;=low;j--){
            A[j+1]=A[j];
        }
        A[low]=A[0];
    }
}
</code></pre>
<h3 id='希尔排序'>希尔排序</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-09 095914.png" referrerpolicy="no-referrer"></p>
<pre><code class='language-c' lang='c'>void ShellSort(int A[],int n){
    int d,i,j;
    for(d=n/2;d&gt;0;d=d/2)
        for(i=d+1;i&lt;n;i++)
            if(A[i]&gt;A[i-d]){
                A[0]=A[i];
                for(j=i-d;j&gt;0&amp;&amp;A[0]&lt;A[j];j=j+d)
                A[j+d]=A[j];
       			A[j+d]=A[0];
        }
    }
</code></pre>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-09 100036.png" referrerpolicy="no-referrer"></p>
<h3 id='冒泡排序'>冒泡排序</h3>
<p>  </p>
<pre><code class='language-c' lang='c'>void BubbleSort(int A[],int n){
    for(i=0;i&lt;n;i++){
        bool flag=false;
        for(j=n-1;j&gt;i;j--){
            if(A[j-1]&gt;A[j]){
                int temp=A[j];
                A[j]=A[j-1];
                A[j-1]=temp;
                flag=true;
            }
          if(flag==true)
              return; 
        }
    }
}
</code></pre>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-09 144402.png" referrerpolicy="no-referrer"></p>
<h3 id='快速排序'>快速排序</h3>
<p>基于“交换”的排序：根据序列中两个元素关键字的⽐较结果来对换这两个记录在序列中的位置</p>
<p>算法思想：在待排序表L[1…n]中任取⼀个元素pivot作为枢轴（或基准，通常取⾸元素），通过⼀趟排序将待排序表划分为独⽴的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素⼩于pivot，L[k+1…n]中的所有元素⼤于等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为⼀次“划分”。然后分别递归地对两个⼦表重复上述过程，直⾄每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。</p>
<pre><code class='language-c' lang='c'>void QuickSort(int A[],int low,int high){
    if(low&lt;high){
        int pivotpos=Partition(int A[],int low,int high);
        QuickSort(A,low,pivotpos-1);
        QuickSort(A,pivotpos+1,high);
    }
        
}


int Partition(int A[],int low,int high){
    int pivot=A[low];
    while(low&lt;high){
        while(low&lt;high&amp;&amp;A[high]&gt;pivot)
            high--;
        A[low]=A[high];
        while(low&lt;high&amp;&amp;A[low]&lt;pivot)
            low--;
        A[high]=A[low];
    }
    A[low]=pivot;
    return low;
}
</code></pre>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-09 152829.png" referrerpolicy="no-referrer"></p>
<p><strong>不稳定</strong></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-09 153346.png" referrerpolicy="no-referrer"></p>
<h3 id='简单选择排序'>简单选择排序</h3>
<pre><code class='language-c' lang='c'>void SelectSort(int A[],int n){
    for(i=0;i&lt;n;i++){
        int min=i;
        for(j=i+1;j&lt;n;j++)
            if(A[j]&lt;A[min])
                min=j;
        if(min!=i){
            int temp=A[i];
            A[i]=A[min];
            A[min]=temp;
            }
            
        }
    }
</code></pre>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-09 160920.png" referrerpolicy="no-referrer"></p>
<h3 id='堆排序'>堆排序</h3>
<p>若<em>n</em>个关键字序列L[1…n] 满⾜下⾯某⼀条性质，则称为堆（Heap）： </p>
<p>① 若满⾜：L(i)≥L(2i)且L(i)≥L(2i+1) （1 ≤ <em>i</em> ≤<em>n</em>/2）—— ⼤根堆（⼤顶堆）</p>
<p>② 若满⾜：L(i)≤L(2i)且L(i)≤L(2i+1) （1 ≤ <em>i</em> ≤<em>n</em>/2）—— ⼩根堆（⼩顶堆）</p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-10 103040.png" referrerpolicy="no-referrer"></p>
<pre><code class='language-c' lang='c'>void BuildMaxHeap(int A[],int len){
    for(i=n/2;i&gt;0;i++)
        HeadAdjust(A[],i,len);
}
void HeadAdjust(int A[],int k;int len){
    A[0]=A[k];
    for(i=2*k;i&lt;=len;i=i*2)
        if(i&lt;len&amp;&amp;A[i]&lt;A[i+1])
            i++;
    if(A[k]&gt;=A[i])
        break;
    else{
        A[k]=A[i];
        k=i;
    }
        A[k]=A[0];    
}
void HeadSort(int A[],int len){
    BuildMaxHeap(int A[],int len);
    for(i=len;i&gt;1;i--){
        swap(A[i],A[1]);
        HeapAdjust(A,1,i-1);
    }
}
</code></pre>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-10 150845.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-10 151030.png" referrerpolicy="no-referrer"></p>
<p><strong>此算法是不稳定的</strong></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-10 151240.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-10 153454.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-10 153543.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-10 153606.png" referrerpolicy="no-referrer"></p>
<h3 id='归并排序'>归并排序</h3>
<p>归并：把两个或多个已经有序的序列合并成⼀个</p>
<pre><code class='language-c' lang='c'>void Merge(int A[],int low,int mid,int high){
    int i,j,k;
    for(k=low;k&lt;high;k++){
        B[k]=A[k];
    }
    for(i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++){
        if(B[i]&lt;=B[j])
            A[k]=B[i++];
        else
            A[k]=B[j++];
        
    }
    while(i&lt;=mid) A[k++]=B[i++];
    while(j&lt;=mid) A[k++]=B[j++]
}
//将左右两个⼦序列分别进⾏归并排序（每个⼦序列只含有1个元素）
void MergeSort(int A[],int low,int high){
    if(low&lt;high){
        int mid =(low+high)/2;
        MergeSort(A,low,mid);
        MergeSort(A,mid+1,high);
        Merge(A,low,mid,high);
    }
}
</code></pre>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-10 202039.png" referrerpolicy="no-referrer"></p>
<h3 id='基数排序'>基数排序</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-10 202039.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-11 103824.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-11 103411.png" referrerpolicy="no-referrer"></p>
<h3 id='外部排序'>外部排序</h3>
<p><strong>外部排序时间开销读写外存的时间+内部排序所需时间+*内部归并所需时间</strong></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-11 143713.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-11 143806.png" referrerpolicy="no-referrer"></p>
<h3 id='败者树'>败者树</h3>
<p>败者树——可视为⼀棵完全⼆叉树（多了⼀个头头）。<em>k</em>个叶结点分别是当前参加⽐较的元素，⾮叶⼦结点⽤来记忆左右⼦树中的“失败者”，⽽让胜者往上继续进⾏⽐较，⼀直到根结点。</p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-11 155725.png" referrerpolicy="no-referrer"></p>
<h3 id='置换-选择排序'>置换-选择排序</h3>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-11 164122.png" referrerpolicy="no-referrer"></p>
<h3 id='最佳归并树'>最佳归并树</h3>
<p><strong>归并过程中的磁盘I/O次数= 归并树的WPL * 2</strong></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-11 165000.png" referrerpolicy="no-referrer"></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-11 165046.png" referrerpolicy="no-referrer"></p>
<p><strong>注意：对于k叉归并，若初始归并段的数量⽆法构成严格的 k 叉归并树， 则需要补充⼏个⻓度为 0 的“虚段”，再进⾏ k 叉哈夫曼树的构造。</strong></p>
<p><img src="C:\Users\84569\Pictures\屏幕截图 2021-08-11 165548.png" referrerpolicy="no-referrer"></p>
<p>&nbsp;</p>
</body>
</html>
